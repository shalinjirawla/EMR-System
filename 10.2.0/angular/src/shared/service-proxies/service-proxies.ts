//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdmissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateAdmissionDto | undefined): Observable<AdmissionDto> {
        let url_ = this.baseUrl + "/api/services/app/Admission/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdmissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdmissionDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AdmissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdmissionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<AdmissionDto> {
        let url_ = this.baseUrl + "/api/services/app/Admission/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdmissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdmissionDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AdmissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdmissionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AdmissionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Admission/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdmissionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdmissionDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdmissionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdmissionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateAdmissionDto | undefined): Observable<AdmissionDto> {
        let url_ = this.baseUrl + "/api/services/app/Admission/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdmissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdmissionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AdmissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdmissionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Admission/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppointmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param patientId (optional) 
     * @param doctorId (optional) 
     * @return OK
     */
    getPatientAppointment(patientId: number | undefined, doctorId: number | undefined): Observable<AppointmentDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/GetPatientAppointment?";
        if (patientId === null)
            throw new Error("The parameter 'patientId' cannot be null.");
        else if (patientId !== undefined)
            url_ += "patientId=" + encodeURIComponent("" + patientId) + "&";
        if (doctorId === null)
            throw new Error("The parameter 'doctorId' cannot be null.");
        else if (doctorId !== undefined)
            url_ += "doctorId=" + encodeURIComponent("" + doctorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPatientAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPatientAppointment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentDtoListResultDto>;
        }));
    }

    protected processGetPatientAppointment(response: HttpResponseBase): Observable<AppointmentDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param patientId (optional) 
     * @return OK
     */
    getByPatient(patientId: number | undefined): Observable<AppointmentDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/GetByPatient?";
        if (patientId === null)
            throw new Error("The parameter 'patientId' cannot be null.");
        else if (patientId !== undefined)
            url_ += "patientId=" + encodeURIComponent("" + patientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByPatient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByPatient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentDtoListResultDto>;
        }));
    }

    protected processGetByPatient(response: HttpResponseBase): Observable<AppointmentDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getAppointmentDetailsById(id: number | undefined): Observable<CreateUpdateAppointmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/GetAppointmentDetailsById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppointmentDetailsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppointmentDetailsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateUpdateAppointmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateUpdateAppointmentDto>;
        }));
    }

    protected processGetAppointmentDetailsById(response: HttpResponseBase): Observable<CreateUpdateAppointmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateUpdateAppointmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createAppoinment(body: CreateUpdateAppointmentDto | undefined): Observable<AppointmentCreationResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/CreateAppoinment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAppoinment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAppoinment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentCreationResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentCreationResultDto>;
        }));
    }

    protected processCreateAppoinment(response: HttpResponseBase): Observable<AppointmentCreationResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentCreationResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param appointmentId (optional) 
     * @return OK
     */
    initiatePaymentForAppointment(appointmentId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/InitiatePaymentForAppointment?";
        if (appointmentId === null)
            throw new Error("The parameter 'appointmentId' cannot be null.");
        else if (appointmentId !== undefined)
            url_ += "appointmentId=" + encodeURIComponent("" + appointmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitiatePaymentForAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitiatePaymentForAppointment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processInitiatePaymentForAppointment(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateAppoinment(body: CreateUpdateAppointmentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/UpdateAppoinment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAppoinment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAppoinment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAppoinment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCurrentUserRoles(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/GetCurrentUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetCurrentUserRoles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return OK
     */
    markAsAction(id: number | undefined, body: AppointmentStatus | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/MarkAsAction?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsAction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkAsAction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param appointmentId (optional) 
     * @param paymentMethod (optional) 
     * @return OK
     */
    generateAppointmentReceipt(appointmentId: number | undefined, paymentMethod: string | undefined): Observable<AppointmentReceiptDto> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/GenerateAppointmentReceipt?";
        if (appointmentId === null)
            throw new Error("The parameter 'appointmentId' cannot be null.");
        else if (appointmentId !== undefined)
            url_ += "appointmentId=" + encodeURIComponent("" + appointmentId) + "&";
        if (paymentMethod === null)
            throw new Error("The parameter 'paymentMethod' cannot be null.");
        else if (paymentMethod !== undefined)
            url_ += "paymentMethod=" + encodeURIComponent("" + paymentMethod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateAppointmentReceipt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateAppointmentReceipt(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentReceiptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentReceiptDto>;
        }));
    }

    protected processGenerateAppointmentReceipt(response: HttpResponseBase): Observable<AppointmentReceiptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentReceiptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param appointmentId (optional) 
     * @return OK
     */
    getReceiptForAppointment(appointmentId: number | undefined): Observable<AppointmentReceiptDto> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/GetReceiptForAppointment?";
        if (appointmentId === null)
            throw new Error("The parameter 'appointmentId' cannot be null.");
        else if (appointmentId !== undefined)
            url_ += "appointmentId=" + encodeURIComponent("" + appointmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceiptForAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceiptForAppointment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentReceiptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentReceiptDto>;
        }));
    }

    protected processGetReceiptForAppointment(response: HttpResponseBase): Observable<AppointmentReceiptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentReceiptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param patientId (optional) 
     * @return OK
     */
    getPatientReceipts(patientId: number | undefined): Observable<AppointmentReceiptDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/GetPatientReceipts?";
        if (patientId === null)
            throw new Error("The parameter 'patientId' cannot be null.");
        else if (patientId !== undefined)
            url_ += "patientId=" + encodeURIComponent("" + patientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPatientReceipts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPatientReceipts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentReceiptDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentReceiptDtoListResultDto>;
        }));
    }

    protected processGetPatientReceipts(response: HttpResponseBase): Observable<AppointmentReceiptDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentReceiptDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<AppointmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AppointmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param status (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(keyword: string | undefined, status: AppointmentStatus | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AppointmentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AppointmentDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateAppointmentDto | undefined): Observable<AppointmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AppointmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateAppointmentDto | undefined): Observable<AppointmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AppointmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppointmentTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getAllForTenant(): Observable<AppointmentTypeDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AppointmentType/GetAllForTenant";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllForTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllForTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentTypeDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentTypeDtoListResultDto>;
        }));
    }

    protected processGetAllForTenant(response: HttpResponseBase): Observable<AppointmentTypeDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentTypeDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<AppointmentTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/AppointmentType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AppointmentTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<AppointmentTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AppointmentType/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AppointmentTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateAppointmentTypeDto | undefined): Observable<AppointmentTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/AppointmentType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AppointmentTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateAppointmentTypeDto | undefined): Observable<AppointmentTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/AppointmentType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AppointmentTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppointmentType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BillingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getCurrentUserRoles(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Billing/GetCurrentUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetCurrentUserRoles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<BillingDto> {
        let url_ = this.baseUrl + "/api/services/app/Billing/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BillingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BillingDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BillingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BillingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<BillingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Billing/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BillingDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BillingDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<BillingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BillingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateBillingDto | undefined): Observable<BillingDto> {
        let url_ = this.baseUrl + "/api/services/app/Billing/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BillingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BillingDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BillingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BillingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateBillingDto | undefined): Observable<BillingDto> {
        let url_ = this.baseUrl + "/api/services/app/Billing/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BillingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BillingDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<BillingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BillingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Billing/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DepartmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getAllDepartmentByTenantID(): Observable<DepartmentListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Department/GetAllDepartmentByTenantID";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDepartmentByTenantID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDepartmentByTenantID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentListDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentListDtoListResultDto>;
        }));
    }

    protected processGetAllDepartmentByTenantID(response: HttpResponseBase): Observable<DepartmentListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<DepartmentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Department/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentListDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DepartmentListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DepartmentListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Department/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentListDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DepartmentListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateDepartmentDto | undefined): Observable<DepartmentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Department/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentListDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DepartmentListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateDepartmentDto | undefined): Observable<DepartmentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Department/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentListDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DepartmentListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Department/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DepositServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createDepositWithStripeSupport(body: CreateUpdateDepositDto | undefined): Observable<DepositResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Deposit/CreateDepositWithStripeSupport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDepositWithStripeSupport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDepositWithStripeSupport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepositResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepositResponseDto>;
        }));
    }

    protected processCreateDepositWithStripeSupport(response: HttpResponseBase): Observable<DepositResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepositResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param successUrl (optional) 
     * @param cancelUrl (optional) 
     * @param body (optional) 
     * @return OK
     */
    createStripeCheckoutSessionForDeposit(successUrl: string | undefined, cancelUrl: string | undefined, body: CreateUpdateDepositDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Deposit/CreateStripeCheckoutSessionForDeposit?";
        if (successUrl === null)
            throw new Error("The parameter 'successUrl' cannot be null.");
        else if (successUrl !== undefined)
            url_ += "successUrl=" + encodeURIComponent("" + successUrl) + "&";
        if (cancelUrl === null)
            throw new Error("The parameter 'cancelUrl' cannot be null.");
        else if (cancelUrl !== undefined)
            url_ += "cancelUrl=" + encodeURIComponent("" + cancelUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStripeCheckoutSessionForDeposit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStripeCheckoutSessionForDeposit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateStripeCheckoutSessionForDeposit(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<DepositDto> {
        let url_ = this.baseUrl + "/api/services/app/Deposit/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepositDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepositDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DepositDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepositDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DepositDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Deposit/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepositDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepositDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DepositDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepositDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateDepositDto | undefined): Observable<DepositDto> {
        let url_ = this.baseUrl + "/api/services/app/Deposit/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepositDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepositDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DepositDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepositDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateDepositDto | undefined): Observable<DepositDto> {
        let url_ = this.baseUrl + "/api/services/app/Deposit/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepositDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepositDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DepositDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepositDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Deposit/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DoctorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param tenantId (optional) 
     * @return OK
     */
    getAllDoctorsByTenantID(tenantId: number | undefined): Observable<DoctorDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Doctor/GetAllDoctorsByTenantID?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDoctorsByTenantID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDoctorsByTenantID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorDtoListResultDto>;
        }));
    }

    protected processGetAllDoctorsByTenantID(response: HttpResponseBase): Observable<DoctorDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param abpUserId (optional) 
     * @return OK
     */
    getDoctorDetailsByAbpUserID(abpUserId: number | undefined): Observable<Doctor> {
        let url_ = this.baseUrl + "/api/services/app/Doctor/GetDoctorDetailsByAbpUserID?";
        if (abpUserId === null)
            throw new Error("The parameter 'abpUserId' cannot be null.");
        else if (abpUserId !== undefined)
            url_ += "abpUserId=" + encodeURIComponent("" + abpUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoctorDetailsByAbpUserID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoctorDetailsByAbpUserID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Doctor>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Doctor>;
        }));
    }

    protected processGetDoctorDetailsByAbpUserID(response: HttpResponseBase): Observable<Doctor> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Doctor.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCurrentUserRoles(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Doctor/GetCurrentUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetCurrentUserRoles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<DoctorDto> {
        let url_ = this.baseUrl + "/api/services/app/Doctor/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DoctorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DoctorDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Doctor/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DoctorDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateDoctorDto | undefined): Observable<DoctorDto> {
        let url_ = this.baseUrl + "/api/services/app/Doctor/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DoctorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateDoctorDto | undefined): Observable<DoctorDto> {
        let url_ = this.baseUrl + "/api/services/app/Doctor/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DoctorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Doctor/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DoctorMasterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param tenantId (optional) 
     * @return OK
     */
    getAllByTenantId(tenantId: number | undefined): Observable<DoctorMasterDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DoctorMaster/GetAllByTenantId?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByTenantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorMasterDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorMasterDtoListResultDto>;
        }));
    }

    protected processGetAllByTenantId(response: HttpResponseBase): Observable<DoctorMasterDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorMasterDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<DoctorMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/DoctorMaster/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorMasterDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DoctorMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DoctorMasterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DoctorMaster/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorMasterDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorMasterDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DoctorMasterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorMasterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateDoctorMasterDto | undefined): Observable<DoctorMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/DoctorMaster/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorMasterDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DoctorMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateDoctorMasterDto | undefined): Observable<DoctorMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/DoctorMaster/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorMasterDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DoctorMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DoctorMaster/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param appointmentId (optional) 
     * @return OK
     */
    getInvoiceDetailsByAppointmentIdUsingSp(appointmentId: number | undefined): Observable<InvoiceDetailsDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceDetailsByAppointmentIdUsingSp?";
        if (appointmentId === null)
            throw new Error("The parameter 'appointmentId' cannot be null.");
        else if (appointmentId !== undefined)
            url_ += "appointmentId=" + encodeURIComponent("" + appointmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceDetailsByAppointmentIdUsingSp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceDetailsByAppointmentIdUsingSp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDetailsDto>;
        }));
    }

    protected processGetInvoiceDetailsByAppointmentIdUsingSp(response: HttpResponseBase): Observable<InvoiceDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateInvoiceDto | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @param amount (optional) 
     * @return OK
     */
    markAsPaid(invoiceId: number | undefined, amount: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/MarkAsPaid?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsPaid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsPaid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkAsPaid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @param amount (optional) 
     * @param successUrl (optional) 
     * @param cancelUrl (optional) 
     * @return OK
     */
    createStripeCheckoutSession(invoiceId: number | undefined, amount: number | undefined, successUrl: string | undefined, cancelUrl: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateStripeCheckoutSession?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        if (successUrl === null)
            throw new Error("The parameter 'successUrl' cannot be null.");
        else if (successUrl !== undefined)
            url_ += "successUrl=" + encodeURIComponent("" + successUrl) + "&";
        if (cancelUrl === null)
            throw new Error("The parameter 'cancelUrl' cannot be null.");
        else if (cancelUrl !== undefined)
            url_ += "cancelUrl=" + encodeURIComponent("" + cancelUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStripeCheckoutSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStripeCheckoutSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateStripeCheckoutSession(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<InvoiceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<InvoiceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateInvoiceDto | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LabReportResultItemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addLabReportResultItem(body: CreateUpdateLabReportResultItemDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LabReportResultItem/AddLabReportResultItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddLabReportResultItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddLabReportResultItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddLabReportResultItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param prescriptionLabTestId (optional) 
     * @return OK
     */
    getLabReportResultItemsById(prescriptionLabTestId: number | undefined): Observable<CreateUpdateLabReportResultItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LabReportResultItem/GetLabReportResultItemsById?";
        if (prescriptionLabTestId === null)
            throw new Error("The parameter 'prescriptionLabTestId' cannot be null.");
        else if (prescriptionLabTestId !== undefined)
            url_ += "prescriptionLabTestId=" + encodeURIComponent("" + prescriptionLabTestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLabReportResultItemsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLabReportResultItemsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateUpdateLabReportResultItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateUpdateLabReportResultItemDto[]>;
        }));
    }

    protected processGetLabReportResultItemsById(response: HttpResponseBase): Observable<CreateUpdateLabReportResultItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CreateUpdateLabReportResultItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    editLabReportResultItem(body: CreateUpdateLabReportResultItemDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LabReportResultItem/EditLabReportResultItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditLabReportResultItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditLabReportResultItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditLabReportResultItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param prescriptionLabTestId (optional) 
     * @return OK
     */
    viewLabReport(prescriptionLabTestId: number | undefined): Observable<ViewLabReportDto> {
        let url_ = this.baseUrl + "/api/services/app/LabReportResultItem/ViewLabReport?";
        if (prescriptionLabTestId === null)
            throw new Error("The parameter 'prescriptionLabTestId' cannot be null.");
        else if (prescriptionLabTestId !== undefined)
            url_ += "prescriptionLabTestId=" + encodeURIComponent("" + prescriptionLabTestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViewLabReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewLabReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViewLabReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViewLabReportDto>;
        }));
    }

    protected processViewLabReport(response: HttpResponseBase): Observable<ViewLabReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewLabReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<LabReportResultItemDto> {
        let url_ = this.baseUrl + "/api/services/app/LabReportResultItem/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabReportResultItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabReportResultItemDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LabReportResultItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabReportResultItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LabReportResultItemDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LabReportResultItem/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabReportResultItemDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabReportResultItemDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LabReportResultItemDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabReportResultItemDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateLabReportResultItemDto | undefined): Observable<LabReportResultItemDto> {
        let url_ = this.baseUrl + "/api/services/app/LabReportResultItem/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabReportResultItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabReportResultItemDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LabReportResultItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabReportResultItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateLabReportResultItemDto | undefined): Observable<LabReportResultItemDto> {
        let url_ = this.baseUrl + "/api/services/app/LabReportResultItem/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabReportResultItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabReportResultItemDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LabReportResultItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabReportResultItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LabReportResultItem/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LabReportsTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param tenantId (optional) 
     * @return OK
     */
    getAllTestByTenantID(tenantId: number | undefined): Observable<LabReportsTypeDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LabReportsType/GetAllTestByTenantID?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTestByTenantID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTestByTenantID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabReportsTypeDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabReportsTypeDtoListResultDto>;
        }));
    }

    protected processGetAllTestByTenantID(response: HttpResponseBase): Observable<LabReportsTypeDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabReportsTypeDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<LabReportsTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/LabReportsType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabReportsTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabReportsTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LabReportsTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabReportsTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LabReportsTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LabReportsType/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabReportsTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabReportsTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LabReportsTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabReportsTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateLabReportTypeDto | undefined): Observable<LabReportsTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/LabReportsType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabReportsTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabReportsTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LabReportsTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabReportsTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateLabReportTypeDto | undefined): Observable<LabReportsTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/LabReportsType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabReportsTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabReportsTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LabReportsTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabReportsTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LabReportsType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LapTechnicianServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getCurrentUserRoles(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/LapTechnician/GetCurrentUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetCurrentUserRoles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<LabTechniciansDto> {
        let url_ = this.baseUrl + "/api/services/app/LapTechnician/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabTechniciansDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabTechniciansDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LabTechniciansDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabTechniciansDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LabTechniciansDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LapTechnician/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabTechniciansDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabTechniciansDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LabTechniciansDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabTechniciansDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateLabTechnicianDto | undefined): Observable<LabTechniciansDto> {
        let url_ = this.baseUrl + "/api/services/app/LapTechnician/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabTechniciansDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabTechniciansDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LabTechniciansDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabTechniciansDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateLabTechnicianDto | undefined): Observable<LabTechniciansDto> {
        let url_ = this.baseUrl + "/api/services/app/LapTechnician/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabTechniciansDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabTechniciansDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LabTechniciansDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabTechniciansDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LapTechnician/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MedicineOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createMedicineOrderWithItem(body: CreateUpdateMedicineOrderDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MedicineOrder/CreateMedicineOrderWithItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMedicineOrderWithItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMedicineOrderWithItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateMedicineOrderWithItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateMedicineOrderWithItem(body: CreateUpdateMedicineOrderDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MedicineOrder/UpdateMedicineOrderWithItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMedicineOrderWithItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMedicineOrderWithItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateMedicineOrderWithItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getOrderDetailsById(id: number | undefined): Observable<CreateUpdateMedicineOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/MedicineOrder/GetOrderDetailsById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderDetailsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderDetailsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateUpdateMedicineOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateUpdateMedicineOrderDto>;
        }));
    }

    protected processGetOrderDetailsById(response: HttpResponseBase): Observable<CreateUpdateMedicineOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateUpdateMedicineOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<MedicineOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/MedicineOrder/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MedicineOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MedicineOrderDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MedicineOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicineOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<MedicineOrderDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MedicineOrder/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MedicineOrderDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MedicineOrderDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MedicineOrderDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicineOrderDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateMedicineOrderDto | undefined): Observable<MedicineOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/MedicineOrder/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MedicineOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MedicineOrderDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MedicineOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicineOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateMedicineOrderDto | undefined): Observable<MedicineOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/MedicineOrder/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MedicineOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MedicineOrderDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MedicineOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicineOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MedicineOrder/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NurseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param tenantId (optional) 
     * @return OK
     */
    getAllNursesByTenantID(tenantId: number | undefined): Observable<NurseDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Nurse/GetAllNursesByTenantID?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNursesByTenantID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNursesByTenantID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NurseDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NurseDtoListResultDto>;
        }));
    }

    protected processGetAllNursesByTenantID(response: HttpResponseBase): Observable<NurseDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NurseDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param abpUserId (optional) 
     * @return OK
     */
    getNurseDetailsByAbpUserID(abpUserId: number | undefined): Observable<Nurse> {
        let url_ = this.baseUrl + "/api/services/app/Nurse/GetNurseDetailsByAbpUserID?";
        if (abpUserId === null)
            throw new Error("The parameter 'abpUserId' cannot be null.");
        else if (abpUserId !== undefined)
            url_ += "abpUserId=" + encodeURIComponent("" + abpUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNurseDetailsByAbpUserID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNurseDetailsByAbpUserID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Nurse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Nurse>;
        }));
    }

    protected processGetNurseDetailsByAbpUserID(response: HttpResponseBase): Observable<Nurse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Nurse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCurrentUserRoles(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Nurse/GetCurrentUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetCurrentUserRoles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<NurseDto> {
        let url_ = this.baseUrl + "/api/services/app/Nurse/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NurseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NurseDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<NurseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NurseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<NurseDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Nurse/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NurseDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NurseDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<NurseDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NurseDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateNurseDto | undefined): Observable<NurseDto> {
        let url_ = this.baseUrl + "/api/services/app/Nurse/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NurseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NurseDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<NurseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NurseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateNurseDto | undefined): Observable<NurseDto> {
        let url_ = this.baseUrl + "/api/services/app/Nurse/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NurseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NurseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<NurseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NurseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Nurse/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PatientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdatePatientDto | undefined): Observable<PatientDto> {
        let url_ = this.baseUrl + "/api/services/app/Patient/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PatientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PatientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdatePatientDto | undefined): Observable<PatientDto> {
        let url_ = this.baseUrl + "/api/services/app/Patient/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PatientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PatientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Patient/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    patientsForNurse(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PatientsForDoctorAndNurseDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Patient/PatientsForNurse?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatientsForNurse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatientsForNurse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientsForDoctorAndNurseDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientsForDoctorAndNurseDtoPagedResultDto>;
        }));
    }

    protected processPatientsForNurse(response: HttpResponseBase): Observable<PatientsForDoctorAndNurseDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PatientsForDoctorAndNurseDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    patientsForDoctor(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PatientsForDoctorAndNurseDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Patient/PatientsForDoctor?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatientsForDoctor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatientsForDoctor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientsForDoctorAndNurseDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientsForDoctorAndNurseDtoPagedResultDto>;
        }));
    }

    protected processPatientsForDoctor(response: HttpResponseBase): Observable<PatientsForDoctorAndNurseDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PatientsForDoctorAndNurseDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param patientId (optional) 
     * @return OK
     */
    patientDetailsAndMedicalHistory(patientId: number | undefined): Observable<PatientDetailsAndMedicalHistoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Patient/PatientDetailsAndMedicalHistory?";
        if (patientId === null)
            throw new Error("The parameter 'patientId' cannot be null.");
        else if (patientId !== undefined)
            url_ += "patientId=" + encodeURIComponent("" + patientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatientDetailsAndMedicalHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatientDetailsAndMedicalHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientDetailsAndMedicalHistoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientDetailsAndMedicalHistoryDto>;
        }));
    }

    protected processPatientDetailsAndMedicalHistory(response: HttpResponseBase): Observable<PatientDetailsAndMedicalHistoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PatientDetailsAndMedicalHistoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    patientDropDown(): Observable<PatientDropDownDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Patient/PatientDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatientDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatientDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientDropDownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientDropDownDto[]>;
        }));
    }

    protected processPatientDropDown(response: HttpResponseBase): Observable<PatientDropDownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PatientDropDownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCurrentUserRoles(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Patient/GetCurrentUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetCurrentUserRoles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param patientId (optional) 
     * @param amount (optional) 
     * @param successUrl (optional) 
     * @param cancelUrl (optional) 
     * @return OK
     */
    createStripeCheckoutSessionForDeposit(patientId: number | undefined, amount: number | undefined, successUrl: string | undefined, cancelUrl: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Patient/CreateStripeCheckoutSessionForDeposit?";
        if (patientId === null)
            throw new Error("The parameter 'patientId' cannot be null.");
        else if (patientId !== undefined)
            url_ += "patientId=" + encodeURIComponent("" + patientId) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        if (successUrl === null)
            throw new Error("The parameter 'successUrl' cannot be null.");
        else if (successUrl !== undefined)
            url_ += "successUrl=" + encodeURIComponent("" + successUrl) + "&";
        if (cancelUrl === null)
            throw new Error("The parameter 'cancelUrl' cannot be null.");
        else if (cancelUrl !== undefined)
            url_ += "cancelUrl=" + encodeURIComponent("" + cancelUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStripeCheckoutSessionForDeposit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStripeCheckoutSessionForDeposit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateStripeCheckoutSessionForDeposit(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<PatientDto> {
        let url_ = this.baseUrl + "/api/services/app/Patient/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PatientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PatientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PatientDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Patient/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PatientDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PatientDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PharmacistServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<PharmacistDto> {
        let url_ = this.baseUrl + "/api/services/app/Pharmacist/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PharmacistDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PharmacistDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PharmacistDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PharmacistDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PharmacistDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Pharmacist/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PharmacistDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PharmacistDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PharmacistDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PharmacistDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdatePharmacistDto | undefined): Observable<PharmacistDto> {
        let url_ = this.baseUrl + "/api/services/app/Pharmacist/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PharmacistDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PharmacistDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PharmacistDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PharmacistDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdatePharmacistDto | undefined): Observable<PharmacistDto> {
        let url_ = this.baseUrl + "/api/services/app/Pharmacist/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PharmacistDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PharmacistDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PharmacistDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PharmacistDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Pharmacist/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PharmacistInventoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param tenantId (optional) 
     * @return OK
     */
    getAllByTenantId(tenantId: number | undefined): Observable<PharmacistInventoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PharmacistInventory/GetAllByTenantId?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByTenantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PharmacistInventoryDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PharmacistInventoryDtoPagedResultDto>;
        }));
    }

    protected processGetAllByTenantId(response: HttpResponseBase): Observable<PharmacistInventoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PharmacistInventoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<PharmacistInventoryDto> {
        let url_ = this.baseUrl + "/api/services/app/PharmacistInventory/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PharmacistInventoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PharmacistInventoryDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PharmacistInventoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PharmacistInventoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param stock (optional) 
     * @param fromExpiryDate (optional) 
     * @param toExpiryDate (optional) 
     * @param isAvailable (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(keyword: string | undefined, sorting: string | undefined, stock: number | undefined, fromExpiryDate: moment.Moment | undefined, toExpiryDate: moment.Moment | undefined, isAvailable: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PharmacistInventoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PharmacistInventory/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (stock === null)
            throw new Error("The parameter 'stock' cannot be null.");
        else if (stock !== undefined)
            url_ += "Stock=" + encodeURIComponent("" + stock) + "&";
        if (fromExpiryDate === null)
            throw new Error("The parameter 'fromExpiryDate' cannot be null.");
        else if (fromExpiryDate !== undefined)
            url_ += "FromExpiryDate=" + encodeURIComponent(fromExpiryDate ? "" + fromExpiryDate.toISOString() : "") + "&";
        if (toExpiryDate === null)
            throw new Error("The parameter 'toExpiryDate' cannot be null.");
        else if (toExpiryDate !== undefined)
            url_ += "ToExpiryDate=" + encodeURIComponent(toExpiryDate ? "" + toExpiryDate.toISOString() : "") + "&";
        if (isAvailable === null)
            throw new Error("The parameter 'isAvailable' cannot be null.");
        else if (isAvailable !== undefined)
            url_ += "IsAvailable=" + encodeURIComponent("" + isAvailable) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PharmacistInventoryDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PharmacistInventoryDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PharmacistInventoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PharmacistInventoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdatePharmacistInventoryDto | undefined): Observable<PharmacistInventoryDto> {
        let url_ = this.baseUrl + "/api/services/app/PharmacistInventory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PharmacistInventoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PharmacistInventoryDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PharmacistInventoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PharmacistInventoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdatePharmacistInventoryDto | undefined): Observable<PharmacistInventoryDto> {
        let url_ = this.baseUrl + "/api/services/app/PharmacistInventory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PharmacistInventoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PharmacistInventoryDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PharmacistInventoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PharmacistInventoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PharmacistInventory/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PrescriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createPrescriptionWithItem(body: CreateUpdatePrescriptionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Prescription/CreatePrescriptionWithItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePrescriptionWithItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePrescriptionWithItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreatePrescriptionWithItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updatePrescriptionWithItem(body: CreateUpdatePrescriptionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Prescription/UpdatePrescriptionWithItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePrescriptionWithItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePrescriptionWithItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePrescriptionWithItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getPrescriptionDetailsById(id: number | undefined): Observable<CreateUpdatePrescriptionDto> {
        let url_ = this.baseUrl + "/api/services/app/Prescription/GetPrescriptionDetailsById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrescriptionDetailsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrescriptionDetailsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateUpdatePrescriptionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateUpdatePrescriptionDto>;
        }));
    }

    protected processGetPrescriptionDetailsById(response: HttpResponseBase): Observable<CreateUpdatePrescriptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateUpdatePrescriptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCurrentUserRoles(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Prescription/GetCurrentUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetCurrentUserRoles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<PrescriptionDto> {
        let url_ = this.baseUrl + "/api/services/app/Prescription/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrescriptionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrescriptionDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PrescriptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrescriptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(keyword: string | undefined, sorting: string | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PrescriptionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Prescription/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrescriptionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrescriptionDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PrescriptionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrescriptionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdatePrescriptionDto | undefined): Observable<PrescriptionDto> {
        let url_ = this.baseUrl + "/api/services/app/Prescription/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrescriptionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrescriptionDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PrescriptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrescriptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdatePrescriptionDto | undefined): Observable<PrescriptionDto> {
        let url_ = this.baseUrl + "/api/services/app/Prescription/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrescriptionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrescriptionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PrescriptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrescriptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Prescription/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PrescriptionItemsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<PrescriptionItemDto> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionItems/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrescriptionItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrescriptionItemDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PrescriptionItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrescriptionItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PrescriptionItemDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionItems/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrescriptionItemDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrescriptionItemDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PrescriptionItemDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrescriptionItemDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdatePrescriptionItemDto | undefined): Observable<PrescriptionItemDto> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionItems/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrescriptionItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrescriptionItemDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PrescriptionItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrescriptionItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdatePrescriptionItemDto | undefined): Observable<PrescriptionItemDto> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionItems/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrescriptionItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrescriptionItemDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PrescriptionItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrescriptionItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionItems/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PrescriptionLabTestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAllLabTestRequests(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LabRequestListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionLabTests/GetAllLabTestRequests?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLabTestRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLabTestRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabRequestListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabRequestListDtoPagedResultDto>;
        }));
    }

    protected processGetAllLabTestRequests(response: HttpResponseBase): Observable<LabRequestListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabRequestListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAllLabOrders(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LabOrderListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionLabTests/GetAllLabOrders?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLabOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLabOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabOrderListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabOrderListDtoPagedResultDto>;
        }));
    }

    protected processGetAllLabOrders(response: HttpResponseBase): Observable<LabOrderListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabOrderListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getPrescriptionLabTestDetailsById(id: number | undefined): Observable<PrescriptionLabTest> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionLabTests/GetPrescriptionLabTestDetailsById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrescriptionLabTestDetailsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrescriptionLabTestDetailsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrescriptionLabTest>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrescriptionLabTest>;
        }));
    }

    protected processGetPrescriptionLabTestDetailsById(response: HttpResponseBase): Observable<PrescriptionLabTest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrescriptionLabTest.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getPrescriptionLabTestDetailsForViewReportById(id: number | undefined): Observable<PrescriptionLabTest> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionLabTests/GetPrescriptionLabTestDetailsForViewReportById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrescriptionLabTestDetailsForViewReportById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrescriptionLabTestDetailsForViewReportById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrescriptionLabTest>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrescriptionLabTest>;
        }));
    }

    protected processGetPrescriptionLabTestDetailsForViewReportById(response: HttpResponseBase): Observable<PrescriptionLabTest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrescriptionLabTest.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param prescriptionLabTestId (optional) 
     * @return OK
     */
    makeCompleteReport(prescriptionLabTestId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionLabTests/MakeCompleteReport?";
        if (prescriptionLabTestId === null)
            throw new Error("The parameter 'prescriptionLabTestId' cannot be null.");
        else if (prescriptionLabTestId !== undefined)
            url_ += "prescriptionLabTestId=" + encodeURIComponent("" + prescriptionLabTestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMakeCompleteReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMakeCompleteReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMakeCompleteReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param prescriptionLabTestId (optional) 
     * @return OK
     */
    makeInprogressReport(prescriptionLabTestId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionLabTests/MakeInprogressReport?";
        if (prescriptionLabTestId === null)
            throw new Error("The parameter 'prescriptionLabTestId' cannot be null.");
        else if (prescriptionLabTestId !== undefined)
            url_ += "prescriptionLabTestId=" + encodeURIComponent("" + prescriptionLabTestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMakeInprogressReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMakeInprogressReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMakeInprogressReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCurrentUserRoles(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionLabTests/GetCurrentUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetCurrentUserRoles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<LabRequestListDto> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionLabTests/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabRequestListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabRequestListDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LabRequestListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabRequestListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LabRequestListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionLabTests/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabRequestListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabRequestListDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LabRequestListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabRequestListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateLabRequestDto | undefined): Observable<LabRequestListDto> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionLabTests/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabRequestListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabRequestListDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LabRequestListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabRequestListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateLabRequestDto | undefined): Observable<LabRequestListDto> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionLabTests/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LabRequestListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LabRequestListDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LabRequestListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LabRequestListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrescriptionLabTests/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param permission (optional) 
     * @return OK
     */
    getRoles(permission: string | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleListDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleListDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoListResultDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createBulkRooms(body: CreateUpdateRoomDto[] | undefined): Observable<RoomDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Room/CreateBulkRooms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBulkRooms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBulkRooms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomDto[]>;
        }));
    }

    protected processCreateBulkRooms(response: HttpResponseBase): Observable<RoomDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RoomDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getRoomDetailsById(id: number | undefined): Observable<CreateUpdateRoomDto> {
        let url_ = this.baseUrl + "/api/services/app/Room/GetRoomDetailsById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoomDetailsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoomDetailsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateUpdateRoomDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateUpdateRoomDto>;
        }));
    }

    protected processGetRoomDetailsById(response: HttpResponseBase): Observable<CreateUpdateRoomDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateUpdateRoomDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @return OK
     */
    getAvailableRooms(tenantId: number | undefined): Observable<RoomDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Room/GetAvailableRooms?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableRooms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableRooms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomDto[]>;
        }));
    }

    protected processGetAvailableRooms(response: HttpResponseBase): Observable<RoomDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RoomDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<RoomDto> {
        let url_ = this.baseUrl + "/api/services/app/Room/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoomDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param roomTypeMasterId (optional) 
     * @param status (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(keyword: string | undefined, roomTypeMasterId: number | undefined, status: RoomStatus | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoomDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Room/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (roomTypeMasterId === null)
            throw new Error("The parameter 'roomTypeMasterId' cannot be null.");
        else if (roomTypeMasterId !== undefined)
            url_ += "RoomTypeMasterId=" + encodeURIComponent("" + roomTypeMasterId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoomDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateRoomDto | undefined): Observable<RoomDto> {
        let url_ = this.baseUrl + "/api/services/app/Room/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoomDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateRoomDto | undefined): Observable<RoomDto> {
        let url_ = this.baseUrl + "/api/services/app/Room/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoomDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Room/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoomFacilityMasterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param tenantId (optional) 
     * @return OK
     */
    getAllRoomFacilityByTenantID(tenantId: number | undefined): Observable<RoomFacilityMasterDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RoomFacilityMaster/GetAllRoomFacilityByTenantID?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoomFacilityByTenantID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoomFacilityByTenantID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomFacilityMasterDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomFacilityMasterDtoListResultDto>;
        }));
    }

    protected processGetAllRoomFacilityByTenantID(response: HttpResponseBase): Observable<RoomFacilityMasterDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomFacilityMasterDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<RoomFacilityMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/RoomFacilityMaster/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomFacilityMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomFacilityMasterDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoomFacilityMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomFacilityMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoomFacilityMasterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RoomFacilityMaster/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomFacilityMasterDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomFacilityMasterDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoomFacilityMasterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomFacilityMasterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateRoomFacilityMasterDto | undefined): Observable<RoomFacilityMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/RoomFacilityMaster/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomFacilityMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomFacilityMasterDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoomFacilityMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomFacilityMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateRoomFacilityMasterDto | undefined): Observable<RoomFacilityMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/RoomFacilityMaster/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomFacilityMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomFacilityMasterDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoomFacilityMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomFacilityMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RoomFacilityMaster/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoomTypeMasterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<RoomTypeMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/RoomTypeMaster/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomTypeMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomTypeMasterDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoomTypeMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomTypeMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateRoomTypeMasterDto | undefined): Observable<RoomTypeMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/RoomTypeMaster/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomTypeMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomTypeMasterDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoomTypeMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomTypeMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateRoomTypeMasterDto | undefined): Observable<RoomTypeMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/RoomTypeMaster/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomTypeMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomTypeMasterDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoomTypeMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomTypeMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createWithFacilities(body: CreateUpdateRoomTypeMasterDto | undefined): Observable<RoomTypeMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/RoomTypeMaster/CreateWithFacilities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWithFacilities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWithFacilities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomTypeMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomTypeMasterDto>;
        }));
    }

    protected processCreateWithFacilities(response: HttpResponseBase): Observable<RoomTypeMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomTypeMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @return OK
     */
    getAllRoomTypeByTenantID(tenantId: number | undefined): Observable<RoomTypeMasterDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RoomTypeMaster/GetAllRoomTypeByTenantID?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoomTypeByTenantID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoomTypeByTenantID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomTypeMasterDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomTypeMasterDtoListResultDto>;
        }));
    }

    protected processGetAllRoomTypeByTenantID(response: HttpResponseBase): Observable<RoomTypeMasterDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomTypeMasterDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateWithFacilities(body: CreateUpdateRoomTypeMasterDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RoomTypeMaster/UpdateWithFacilities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWithFacilities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWithFacilities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateWithFacilities(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getForEdit(id: number | undefined): Observable<CreateUpdateRoomTypeMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/RoomTypeMaster/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateUpdateRoomTypeMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateUpdateRoomTypeMasterDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<CreateUpdateRoomTypeMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateUpdateRoomTypeMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoomTypeMasterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RoomTypeMaster/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomTypeMasterDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomTypeMasterDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoomTypeMasterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomTypeMasterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RoomTypeMaster/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StripeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    webhook(): Observable<void> {
        let url_ = this.baseUrl + "/api/stripe/webhook";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWebhook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWebhook(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWebhook(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    activate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deActivate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeActivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getUserDetailsById(id: number | undefined): Observable<User> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserDetailsById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDetailsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDetailsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processGetUserDetailsById(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VisitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createVisit(body: CreateUpdateVisitDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Visit/CreateVisit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVisit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVisit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateVisit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCurrentUserRoles(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Visit/GetCurrentUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetCurrentUserRoles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<VisitListDto> {
        let url_ = this.baseUrl + "/api/services/app/Visit/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VisitListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VisitListDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<VisitListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VisitListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<VisitListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Visit/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VisitListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VisitListDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VisitListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VisitListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateVisitDto | undefined): Observable<VisitListDto> {
        let url_ = this.baseUrl + "/api/services/app/Visit/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VisitListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VisitListDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<VisitListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VisitListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateVisitDto | undefined): Observable<VisitListDto> {
        let url_ = this.baseUrl + "/api/services/app/Visit/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VisitListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VisitListDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<VisitListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VisitListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Visit/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VitalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateVitalDto | undefined): Observable<VitalDto> {
        let url_ = this.baseUrl + "/api/services/app/Vital/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VitalDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VitalDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<VitalDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VitalDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCurrentUserRoles(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Vital/GetCurrentUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetCurrentUserRoles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<VitalDto> {
        let url_ = this.baseUrl + "/api/services/app/Vital/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VitalDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VitalDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<VitalDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VitalDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<VitalDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Vital/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VitalDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VitalDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VitalDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VitalDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateVitalDto | undefined): Observable<VitalDto> {
        let url_ = this.baseUrl + "/api/services/app/Vital/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VitalDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VitalDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<VitalDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VitalDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vital/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class Admission implements IAdmission {
    id: number;
    tenantId: number;
    patientId: number;
    admissionDateTime: moment.Moment;
    doctorId: number;
    nurseId: number | undefined;
    roomId: number;
    admissionType: AdmissionType;
    patient: Patient;
    doctor: Doctor;
    nurse: Nurse;
    room: Room;

    constructor(data?: IAdmission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.patientId = _data["patientId"];
            this.admissionDateTime = _data["admissionDateTime"] ? moment(_data["admissionDateTime"].toString()) : <any>undefined;
            this.doctorId = _data["doctorId"];
            this.nurseId = _data["nurseId"];
            this.roomId = _data["roomId"];
            this.admissionType = _data["admissionType"];
            this.patient = _data["patient"] ? Patient.fromJS(_data["patient"]) : <any>undefined;
            this.doctor = _data["doctor"] ? Doctor.fromJS(_data["doctor"]) : <any>undefined;
            this.nurse = _data["nurse"] ? Nurse.fromJS(_data["nurse"]) : <any>undefined;
            this.room = _data["room"] ? Room.fromJS(_data["room"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Admission {
        data = typeof data === 'object' ? data : {};
        let result = new Admission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["patientId"] = this.patientId;
        data["admissionDateTime"] = this.admissionDateTime ? this.admissionDateTime.toISOString() : <any>undefined;
        data["doctorId"] = this.doctorId;
        data["nurseId"] = this.nurseId;
        data["roomId"] = this.roomId;
        data["admissionType"] = this.admissionType;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>undefined;
        data["doctor"] = this.doctor ? this.doctor.toJSON() : <any>undefined;
        data["nurse"] = this.nurse ? this.nurse.toJSON() : <any>undefined;
        data["room"] = this.room ? this.room.toJSON() : <any>undefined;
        return data;
    }

    clone(): Admission {
        const json = this.toJSON();
        let result = new Admission();
        result.init(json);
        return result;
    }
}

export interface IAdmission {
    id: number;
    tenantId: number;
    patientId: number;
    admissionDateTime: moment.Moment;
    doctorId: number;
    nurseId: number | undefined;
    roomId: number;
    admissionType: AdmissionType;
    patient: Patient;
    doctor: Doctor;
    nurse: Nurse;
    room: Room;
}

export class AdmissionDto implements IAdmissionDto {
    id: number;
    tenantId: number;
    patientId: number;
    patientName: string | undefined;
    admissionDateTime: moment.Moment;
    doctorId: number;
    doctorName: string | undefined;
    nurseId: number | undefined;
    nurseName: string | undefined;
    roomId: number;
    roomNumber: string | undefined;
    roomTypeName: string | undefined;
    roomTypePricePerDay: number | undefined;
    admissionType: AdmissionType;

    constructor(data?: IAdmissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.patientId = _data["patientId"];
            this.patientName = _data["patientName"];
            this.admissionDateTime = _data["admissionDateTime"] ? moment(_data["admissionDateTime"].toString()) : <any>undefined;
            this.doctorId = _data["doctorId"];
            this.doctorName = _data["doctorName"];
            this.nurseId = _data["nurseId"];
            this.nurseName = _data["nurseName"];
            this.roomId = _data["roomId"];
            this.roomNumber = _data["roomNumber"];
            this.roomTypeName = _data["roomTypeName"];
            this.roomTypePricePerDay = _data["roomTypePricePerDay"];
            this.admissionType = _data["admissionType"];
        }
    }

    static fromJS(data: any): AdmissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdmissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["patientId"] = this.patientId;
        data["patientName"] = this.patientName;
        data["admissionDateTime"] = this.admissionDateTime ? this.admissionDateTime.toISOString() : <any>undefined;
        data["doctorId"] = this.doctorId;
        data["doctorName"] = this.doctorName;
        data["nurseId"] = this.nurseId;
        data["nurseName"] = this.nurseName;
        data["roomId"] = this.roomId;
        data["roomNumber"] = this.roomNumber;
        data["roomTypeName"] = this.roomTypeName;
        data["roomTypePricePerDay"] = this.roomTypePricePerDay;
        data["admissionType"] = this.admissionType;
        return data;
    }

    clone(): AdmissionDto {
        const json = this.toJSON();
        let result = new AdmissionDto();
        result.init(json);
        return result;
    }
}

export interface IAdmissionDto {
    id: number;
    tenantId: number;
    patientId: number;
    patientName: string | undefined;
    admissionDateTime: moment.Moment;
    doctorId: number;
    doctorName: string | undefined;
    nurseId: number | undefined;
    nurseName: string | undefined;
    roomId: number;
    roomNumber: string | undefined;
    roomTypeName: string | undefined;
    roomTypePricePerDay: number | undefined;
    admissionType: AdmissionType;
}

export class AdmissionDtoPagedResultDto implements IAdmissionDtoPagedResultDto {
    items: AdmissionDto[] | undefined;
    totalCount: number;

    constructor(data?: IAdmissionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AdmissionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AdmissionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdmissionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): AdmissionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AdmissionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAdmissionDtoPagedResultDto {
    items: AdmissionDto[] | undefined;
    totalCount: number;
}

export enum AdmissionType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = (<any>this.features)[key];
            }
        }
        return data;
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class Appointment implements IAppointment {
    id: number;
    tenantId: number;
    appointmentDate: moment.Moment;
    reasonForVisit: string | undefined;
    status: AppointmentStatus;
    isFollowUp: boolean;
    isPaid: boolean;
    patientId: number;
    patient: Patient;
    doctorId: number;
    doctor: Doctor;
    appointmentTypeId: number | undefined;
    appointmentType: AppointmentType;
    prescriptions: Prescription[] | undefined;

    constructor(data?: IAppointment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.appointmentDate = _data["appointmentDate"] ? moment(_data["appointmentDate"].toString()) : <any>undefined;
            this.reasonForVisit = _data["reasonForVisit"];
            this.status = _data["status"];
            this.isFollowUp = _data["isFollowUp"];
            this.isPaid = _data["isPaid"];
            this.patientId = _data["patientId"];
            this.patient = _data["patient"] ? Patient.fromJS(_data["patient"]) : <any>undefined;
            this.doctorId = _data["doctorId"];
            this.doctor = _data["doctor"] ? Doctor.fromJS(_data["doctor"]) : <any>undefined;
            this.appointmentTypeId = _data["appointmentTypeId"];
            this.appointmentType = _data["appointmentType"] ? AppointmentType.fromJS(_data["appointmentType"]) : <any>undefined;
            if (Array.isArray(_data["prescriptions"])) {
                this.prescriptions = [] as any;
                for (let item of _data["prescriptions"])
                    this.prescriptions.push(Prescription.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Appointment {
        data = typeof data === 'object' ? data : {};
        let result = new Appointment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>undefined;
        data["reasonForVisit"] = this.reasonForVisit;
        data["status"] = this.status;
        data["isFollowUp"] = this.isFollowUp;
        data["isPaid"] = this.isPaid;
        data["patientId"] = this.patientId;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>undefined;
        data["doctorId"] = this.doctorId;
        data["doctor"] = this.doctor ? this.doctor.toJSON() : <any>undefined;
        data["appointmentTypeId"] = this.appointmentTypeId;
        data["appointmentType"] = this.appointmentType ? this.appointmentType.toJSON() : <any>undefined;
        if (Array.isArray(this.prescriptions)) {
            data["prescriptions"] = [];
            for (let item of this.prescriptions)
                data["prescriptions"].push(item.toJSON());
        }
        return data;
    }

    clone(): Appointment {
        const json = this.toJSON();
        let result = new Appointment();
        result.init(json);
        return result;
    }
}

export interface IAppointment {
    id: number;
    tenantId: number;
    appointmentDate: moment.Moment;
    reasonForVisit: string | undefined;
    status: AppointmentStatus;
    isFollowUp: boolean;
    isPaid: boolean;
    patientId: number;
    patient: Patient;
    doctorId: number;
    doctor: Doctor;
    appointmentTypeId: number | undefined;
    appointmentType: AppointmentType;
    prescriptions: Prescription[] | undefined;
}

export class AppointmentCreationResultDto implements IAppointmentCreationResultDto {
    isStripeRedirect: boolean;
    stripeSessionUrl: string | undefined;
    receipt: AppointmentReceiptDto;

    constructor(data?: IAppointmentCreationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isStripeRedirect = _data["isStripeRedirect"];
            this.stripeSessionUrl = _data["stripeSessionUrl"];
            this.receipt = _data["receipt"] ? AppointmentReceiptDto.fromJS(_data["receipt"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AppointmentCreationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentCreationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isStripeRedirect"] = this.isStripeRedirect;
        data["stripeSessionUrl"] = this.stripeSessionUrl;
        data["receipt"] = this.receipt ? this.receipt.toJSON() : <any>undefined;
        return data;
    }

    clone(): AppointmentCreationResultDto {
        const json = this.toJSON();
        let result = new AppointmentCreationResultDto();
        result.init(json);
        return result;
    }
}

export interface IAppointmentCreationResultDto {
    isStripeRedirect: boolean;
    stripeSessionUrl: string | undefined;
    receipt: AppointmentReceiptDto;
}

export class AppointmentDto implements IAppointmentDto {
    id: number;
    tenantId: number;
    appointmentDate: moment.Moment;
    reasonForVisit: string | undefined;
    status: AppointmentStatus;
    isFollowUp: boolean;
    appointmentTypeId: number;
    isPaid: boolean;
    appointmentType: AppointmentType;
    patient: PatientDto;
    doctor: DoctorDto;
    prescriptions: PrescriptionDto[] | undefined;

    constructor(data?: IAppointmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.appointmentDate = _data["appointmentDate"] ? moment(_data["appointmentDate"].toString()) : <any>undefined;
            this.reasonForVisit = _data["reasonForVisit"];
            this.status = _data["status"];
            this.isFollowUp = _data["isFollowUp"];
            this.appointmentTypeId = _data["appointmentTypeId"];
            this.isPaid = _data["isPaid"];
            this.appointmentType = _data["appointmentType"] ? AppointmentType.fromJS(_data["appointmentType"]) : <any>undefined;
            this.patient = _data["patient"] ? PatientDto.fromJS(_data["patient"]) : <any>undefined;
            this.doctor = _data["doctor"] ? DoctorDto.fromJS(_data["doctor"]) : <any>undefined;
            if (Array.isArray(_data["prescriptions"])) {
                this.prescriptions = [] as any;
                for (let item of _data["prescriptions"])
                    this.prescriptions.push(PrescriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppointmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>undefined;
        data["reasonForVisit"] = this.reasonForVisit;
        data["status"] = this.status;
        data["isFollowUp"] = this.isFollowUp;
        data["appointmentTypeId"] = this.appointmentTypeId;
        data["isPaid"] = this.isPaid;
        data["appointmentType"] = this.appointmentType ? this.appointmentType.toJSON() : <any>undefined;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>undefined;
        data["doctor"] = this.doctor ? this.doctor.toJSON() : <any>undefined;
        if (Array.isArray(this.prescriptions)) {
            data["prescriptions"] = [];
            for (let item of this.prescriptions)
                data["prescriptions"].push(item.toJSON());
        }
        return data;
    }

    clone(): AppointmentDto {
        const json = this.toJSON();
        let result = new AppointmentDto();
        result.init(json);
        return result;
    }
}

export interface IAppointmentDto {
    id: number;
    tenantId: number;
    appointmentDate: moment.Moment;
    reasonForVisit: string | undefined;
    status: AppointmentStatus;
    isFollowUp: boolean;
    appointmentTypeId: number;
    isPaid: boolean;
    appointmentType: AppointmentType;
    patient: PatientDto;
    doctor: DoctorDto;
    prescriptions: PrescriptionDto[] | undefined;
}

export class AppointmentDtoListResultDto implements IAppointmentDtoListResultDto {
    items: AppointmentDto[] | undefined;

    constructor(data?: IAppointmentDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AppointmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppointmentDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AppointmentDtoListResultDto {
        const json = this.toJSON();
        let result = new AppointmentDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IAppointmentDtoListResultDto {
    items: AppointmentDto[] | undefined;
}

export class AppointmentDtoPagedResultDto implements IAppointmentDtoPagedResultDto {
    items: AppointmentDto[] | undefined;
    totalCount: number;

    constructor(data?: IAppointmentDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AppointmentDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AppointmentDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): AppointmentDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AppointmentDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAppointmentDtoPagedResultDto {
    items: AppointmentDto[] | undefined;
    totalCount: number;
}

export class AppointmentReceiptDto implements IAppointmentReceiptDto {
    id: number;
    tenantId: number;
    appointmentId: number;
    patientId: number;
    doctorId: number;
    consultationFee: number;
    receiptNumber: string | undefined;
    paymentDate: moment.Moment;
    paymentMethod: string | undefined;
    patientName: string | undefined;
    doctorName: string | undefined;
    status: string | undefined;
    appointmentDate: string | undefined;

    constructor(data?: IAppointmentReceiptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.appointmentId = _data["appointmentId"];
            this.patientId = _data["patientId"];
            this.doctorId = _data["doctorId"];
            this.consultationFee = _data["consultationFee"];
            this.receiptNumber = _data["receiptNumber"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.paymentMethod = _data["paymentMethod"];
            this.patientName = _data["patientName"];
            this.doctorName = _data["doctorName"];
            this.status = _data["status"];
            this.appointmentDate = _data["appointmentDate"];
        }
    }

    static fromJS(data: any): AppointmentReceiptDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentReceiptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["appointmentId"] = this.appointmentId;
        data["patientId"] = this.patientId;
        data["doctorId"] = this.doctorId;
        data["consultationFee"] = this.consultationFee;
        data["receiptNumber"] = this.receiptNumber;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["paymentMethod"] = this.paymentMethod;
        data["patientName"] = this.patientName;
        data["doctorName"] = this.doctorName;
        data["status"] = this.status;
        data["appointmentDate"] = this.appointmentDate;
        return data;
    }

    clone(): AppointmentReceiptDto {
        const json = this.toJSON();
        let result = new AppointmentReceiptDto();
        result.init(json);
        return result;
    }
}

export interface IAppointmentReceiptDto {
    id: number;
    tenantId: number;
    appointmentId: number;
    patientId: number;
    doctorId: number;
    consultationFee: number;
    receiptNumber: string | undefined;
    paymentDate: moment.Moment;
    paymentMethod: string | undefined;
    patientName: string | undefined;
    doctorName: string | undefined;
    status: string | undefined;
    appointmentDate: string | undefined;
}

export class AppointmentReceiptDtoListResultDto implements IAppointmentReceiptDtoListResultDto {
    items: AppointmentReceiptDto[] | undefined;

    constructor(data?: IAppointmentReceiptDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AppointmentReceiptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppointmentReceiptDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentReceiptDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AppointmentReceiptDtoListResultDto {
        const json = this.toJSON();
        let result = new AppointmentReceiptDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IAppointmentReceiptDtoListResultDto {
    items: AppointmentReceiptDto[] | undefined;
}

export enum AppointmentStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class AppointmentType implements IAppointmentType {
    id: number;
    tenantId: number;
    name: string | undefined;
    description: string | undefined;
    fee: number;
    isActive: boolean;
    creationTime: moment.Moment;

    constructor(data?: IAppointmentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.fee = _data["fee"];
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AppointmentType {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["fee"] = this.fee;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): AppointmentType {
        const json = this.toJSON();
        let result = new AppointmentType();
        result.init(json);
        return result;
    }
}

export interface IAppointmentType {
    id: number;
    tenantId: number;
    name: string | undefined;
    description: string | undefined;
    fee: number;
    isActive: boolean;
    creationTime: moment.Moment;
}

export class AppointmentTypeDto implements IAppointmentTypeDto {
    id: number;
    tenantId: number;
    name: string | undefined;
    description: string | undefined;
    fee: number;
    isActive: boolean;
    creationTime: moment.Moment;

    constructor(data?: IAppointmentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.fee = _data["fee"];
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AppointmentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["fee"] = this.fee;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): AppointmentTypeDto {
        const json = this.toJSON();
        let result = new AppointmentTypeDto();
        result.init(json);
        return result;
    }
}

export interface IAppointmentTypeDto {
    id: number;
    tenantId: number;
    name: string | undefined;
    description: string | undefined;
    fee: number;
    isActive: boolean;
    creationTime: moment.Moment;
}

export class AppointmentTypeDtoListResultDto implements IAppointmentTypeDtoListResultDto {
    items: AppointmentTypeDto[] | undefined;

    constructor(data?: IAppointmentTypeDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AppointmentTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppointmentTypeDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentTypeDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AppointmentTypeDtoListResultDto {
        const json = this.toJSON();
        let result = new AppointmentTypeDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IAppointmentTypeDtoListResultDto {
    items: AppointmentTypeDto[] | undefined;
}

export class AppointmentTypeDtoPagedResultDto implements IAppointmentTypeDtoPagedResultDto {
    items: AppointmentTypeDto[] | undefined;
    totalCount: number;

    constructor(data?: IAppointmentTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AppointmentTypeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AppointmentTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): AppointmentTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AppointmentTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAppointmentTypeDtoPagedResultDto {
    items: AppointmentTypeDto[] | undefined;
    totalCount: number;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data;
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data;
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class Bill implements IBill {
    id: number;
    tenantId: number;
    patientId: number;
    billDate: moment.Moment;
    admissionDate: moment.Moment;
    dateOfSurgery: moment.Moment;
    totalAmount: number;
    paymentStatus: PaymentStatus;
    paymentMethod: string | undefined;
    items: BillItem[] | undefined;
    abpUserId: number;
    abpUser: User;

    constructor(data?: IBill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.patientId = _data["patientId"];
            this.billDate = _data["billDate"] ? moment(_data["billDate"].toString()) : <any>undefined;
            this.admissionDate = _data["admissionDate"] ? moment(_data["admissionDate"].toString()) : <any>undefined;
            this.dateOfSurgery = _data["dateOfSurgery"] ? moment(_data["dateOfSurgery"].toString()) : <any>undefined;
            this.totalAmount = _data["totalAmount"];
            this.paymentStatus = _data["paymentStatus"];
            this.paymentMethod = _data["paymentMethod"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BillItem.fromJS(item));
            }
            this.abpUserId = _data["abpUserId"];
            this.abpUser = _data["abpUser"] ? User.fromJS(_data["abpUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Bill {
        data = typeof data === 'object' ? data : {};
        let result = new Bill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["patientId"] = this.patientId;
        data["billDate"] = this.billDate ? this.billDate.toISOString() : <any>undefined;
        data["admissionDate"] = this.admissionDate ? this.admissionDate.toISOString() : <any>undefined;
        data["dateOfSurgery"] = this.dateOfSurgery ? this.dateOfSurgery.toISOString() : <any>undefined;
        data["totalAmount"] = this.totalAmount;
        data["paymentStatus"] = this.paymentStatus;
        data["paymentMethod"] = this.paymentMethod;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["abpUserId"] = this.abpUserId;
        data["abpUser"] = this.abpUser ? this.abpUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): Bill {
        const json = this.toJSON();
        let result = new Bill();
        result.init(json);
        return result;
    }
}

export interface IBill {
    id: number;
    tenantId: number;
    patientId: number;
    billDate: moment.Moment;
    admissionDate: moment.Moment;
    dateOfSurgery: moment.Moment;
    totalAmount: number;
    paymentStatus: PaymentStatus;
    paymentMethod: string | undefined;
    items: BillItem[] | undefined;
    abpUserId: number;
    abpUser: User;
}

export class BillItem implements IBillItem {
    id: number;
    description: string | undefined;
    quntity: number;
    unitPrice: number;
    amount: number;
    billId: number;
    bill: Bill;

    constructor(data?: IBillItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.quntity = _data["quntity"];
            this.unitPrice = _data["unitPrice"];
            this.amount = _data["amount"];
            this.billId = _data["billId"];
            this.bill = _data["bill"] ? Bill.fromJS(_data["bill"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BillItem {
        data = typeof data === 'object' ? data : {};
        let result = new BillItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["quntity"] = this.quntity;
        data["unitPrice"] = this.unitPrice;
        data["amount"] = this.amount;
        data["billId"] = this.billId;
        data["bill"] = this.bill ? this.bill.toJSON() : <any>undefined;
        return data;
    }

    clone(): BillItem {
        const json = this.toJSON();
        let result = new BillItem();
        result.init(json);
        return result;
    }
}

export interface IBillItem {
    id: number;
    description: string | undefined;
    quntity: number;
    unitPrice: number;
    amount: number;
    billId: number;
    bill: Bill;
}

export class BillItemDto implements IBillItemDto {
    id: number;
    tenantId: number;
    description: string | undefined;
    quntity: number;
    unitPrice: number;
    amount: number;
    billId: number;
    bills: BillingDto;

    constructor(data?: IBillItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.description = _data["description"];
            this.quntity = _data["quntity"];
            this.unitPrice = _data["unitPrice"];
            this.amount = _data["amount"];
            this.billId = _data["billId"];
            this.bills = _data["bills"] ? BillingDto.fromJS(_data["bills"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BillItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["description"] = this.description;
        data["quntity"] = this.quntity;
        data["unitPrice"] = this.unitPrice;
        data["amount"] = this.amount;
        data["billId"] = this.billId;
        data["bills"] = this.bills ? this.bills.toJSON() : <any>undefined;
        return data;
    }

    clone(): BillItemDto {
        const json = this.toJSON();
        let result = new BillItemDto();
        result.init(json);
        return result;
    }
}

export interface IBillItemDto {
    id: number;
    tenantId: number;
    description: string | undefined;
    quntity: number;
    unitPrice: number;
    amount: number;
    billId: number;
    bills: BillingDto;
}

export class BillingDto implements IBillingDto {
    id: number;
    tenantId: number;
    patientId: number;
    generatedByUserId: number | undefined;
    billDate: moment.Moment;
    admissionDate: moment.Moment;
    dateOfSurgery: moment.Moment;
    totalAmount: number;
    paymentStatus: PaymentStatus;
    paymentMethod: string | undefined;
    items: BillItemDto[] | undefined;
    abpUsers: UserDto;

    constructor(data?: IBillingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.patientId = _data["patientId"];
            this.generatedByUserId = _data["generatedByUserId"];
            this.billDate = _data["billDate"] ? moment(_data["billDate"].toString()) : <any>undefined;
            this.admissionDate = _data["admissionDate"] ? moment(_data["admissionDate"].toString()) : <any>undefined;
            this.dateOfSurgery = _data["dateOfSurgery"] ? moment(_data["dateOfSurgery"].toString()) : <any>undefined;
            this.totalAmount = _data["totalAmount"];
            this.paymentStatus = _data["paymentStatus"];
            this.paymentMethod = _data["paymentMethod"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BillItemDto.fromJS(item));
            }
            this.abpUsers = _data["abpUsers"] ? UserDto.fromJS(_data["abpUsers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BillingDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["patientId"] = this.patientId;
        data["generatedByUserId"] = this.generatedByUserId;
        data["billDate"] = this.billDate ? this.billDate.toISOString() : <any>undefined;
        data["admissionDate"] = this.admissionDate ? this.admissionDate.toISOString() : <any>undefined;
        data["dateOfSurgery"] = this.dateOfSurgery ? this.dateOfSurgery.toISOString() : <any>undefined;
        data["totalAmount"] = this.totalAmount;
        data["paymentStatus"] = this.paymentStatus;
        data["paymentMethod"] = this.paymentMethod;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["abpUsers"] = this.abpUsers ? this.abpUsers.toJSON() : <any>undefined;
        return data;
    }

    clone(): BillingDto {
        const json = this.toJSON();
        let result = new BillingDto();
        result.init(json);
        return result;
    }
}

export interface IBillingDto {
    id: number;
    tenantId: number;
    patientId: number;
    generatedByUserId: number | undefined;
    billDate: moment.Moment;
    admissionDate: moment.Moment;
    dateOfSurgery: moment.Moment;
    totalAmount: number;
    paymentStatus: PaymentStatus;
    paymentMethod: string | undefined;
    items: BillItemDto[] | undefined;
    abpUsers: UserDto;
}

export class BillingDtoPagedResultDto implements IBillingDtoPagedResultDto {
    items: BillingDto[] | undefined;
    totalCount: number;

    constructor(data?: IBillingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BillingDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BillingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): BillingDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BillingDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBillingDtoPagedResultDto {
    items: BillingDto[] | undefined;
    totalCount: number;
}

export enum BillingMethod {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data;
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class CreateUpdateAdmissionDto implements ICreateUpdateAdmissionDto {
    id: number;
    tenantId: number;
    patientId: number;
    admissionDateTime: moment.Moment;
    doctorId: number;
    nurseId: number | undefined;
    roomId: number | undefined;
    admissionType: AdmissionType;

    constructor(data?: ICreateUpdateAdmissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.patientId = _data["patientId"];
            this.admissionDateTime = _data["admissionDateTime"] ? moment(_data["admissionDateTime"].toString()) : <any>undefined;
            this.doctorId = _data["doctorId"];
            this.nurseId = _data["nurseId"];
            this.roomId = _data["roomId"];
            this.admissionType = _data["admissionType"];
        }
    }

    static fromJS(data: any): CreateUpdateAdmissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateAdmissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["patientId"] = this.patientId;
        data["admissionDateTime"] = this.admissionDateTime ? this.admissionDateTime.toISOString() : <any>undefined;
        data["doctorId"] = this.doctorId;
        data["nurseId"] = this.nurseId;
        data["roomId"] = this.roomId;
        data["admissionType"] = this.admissionType;
        return data;
    }

    clone(): CreateUpdateAdmissionDto {
        const json = this.toJSON();
        let result = new CreateUpdateAdmissionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateAdmissionDto {
    id: number;
    tenantId: number;
    patientId: number;
    admissionDateTime: moment.Moment;
    doctorId: number;
    nurseId: number | undefined;
    roomId: number | undefined;
    admissionType: AdmissionType;
}

export class CreateUpdateAppointmentDto implements ICreateUpdateAppointmentDto {
    id: number;
    tenantId: number;
    appointmentDate: moment.Moment;
    reasonForVisit: string | undefined;
    status: AppointmentStatus;
    isFollowUp: boolean;
    isPaid: boolean;
    paymentMethod: PaymentMethod;
    patientId: number;
    doctorId: number;
    appointmentTypeId: number | undefined;

    constructor(data?: ICreateUpdateAppointmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.appointmentDate = _data["appointmentDate"] ? moment(_data["appointmentDate"].toString()) : <any>undefined;
            this.reasonForVisit = _data["reasonForVisit"];
            this.status = _data["status"];
            this.isFollowUp = _data["isFollowUp"];
            this.isPaid = _data["isPaid"];
            this.paymentMethod = _data["paymentMethod"];
            this.patientId = _data["patientId"];
            this.doctorId = _data["doctorId"];
            this.appointmentTypeId = _data["appointmentTypeId"];
        }
    }

    static fromJS(data: any): CreateUpdateAppointmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateAppointmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>undefined;
        data["reasonForVisit"] = this.reasonForVisit;
        data["status"] = this.status;
        data["isFollowUp"] = this.isFollowUp;
        data["isPaid"] = this.isPaid;
        data["paymentMethod"] = this.paymentMethod;
        data["patientId"] = this.patientId;
        data["doctorId"] = this.doctorId;
        data["appointmentTypeId"] = this.appointmentTypeId;
        return data;
    }

    clone(): CreateUpdateAppointmentDto {
        const json = this.toJSON();
        let result = new CreateUpdateAppointmentDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateAppointmentDto {
    id: number;
    tenantId: number;
    appointmentDate: moment.Moment;
    reasonForVisit: string | undefined;
    status: AppointmentStatus;
    isFollowUp: boolean;
    isPaid: boolean;
    paymentMethod: PaymentMethod;
    patientId: number;
    doctorId: number;
    appointmentTypeId: number | undefined;
}

export class CreateUpdateAppointmentTypeDto implements ICreateUpdateAppointmentTypeDto {
    id: number;
    tenantId: number;
    name: string | undefined;
    description: string | undefined;
    fee: number;
    isActive: boolean;

    constructor(data?: ICreateUpdateAppointmentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.fee = _data["fee"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateUpdateAppointmentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateAppointmentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["fee"] = this.fee;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateUpdateAppointmentTypeDto {
        const json = this.toJSON();
        let result = new CreateUpdateAppointmentTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateAppointmentTypeDto {
    id: number;
    tenantId: number;
    name: string | undefined;
    description: string | undefined;
    fee: number;
    isActive: boolean;
}

export class CreateUpdateBillingDto implements ICreateUpdateBillingDto {
    id: number;
    tenantId: number;
    patientId: number;
    billDate: moment.Moment;
    admissionDate: moment.Moment;
    dateOfSurgery: moment.Moment;
    totalAmount: number;
    paymentStatus: PaymentStatus;
    paymentMethod: string | undefined;
    items: BillItemDto[] | undefined;
    abpUserId: number;

    constructor(data?: ICreateUpdateBillingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.patientId = _data["patientId"];
            this.billDate = _data["billDate"] ? moment(_data["billDate"].toString()) : <any>undefined;
            this.admissionDate = _data["admissionDate"] ? moment(_data["admissionDate"].toString()) : <any>undefined;
            this.dateOfSurgery = _data["dateOfSurgery"] ? moment(_data["dateOfSurgery"].toString()) : <any>undefined;
            this.totalAmount = _data["totalAmount"];
            this.paymentStatus = _data["paymentStatus"];
            this.paymentMethod = _data["paymentMethod"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BillItemDto.fromJS(item));
            }
            this.abpUserId = _data["abpUserId"];
        }
    }

    static fromJS(data: any): CreateUpdateBillingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateBillingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["patientId"] = this.patientId;
        data["billDate"] = this.billDate ? this.billDate.toISOString() : <any>undefined;
        data["admissionDate"] = this.admissionDate ? this.admissionDate.toISOString() : <any>undefined;
        data["dateOfSurgery"] = this.dateOfSurgery ? this.dateOfSurgery.toISOString() : <any>undefined;
        data["totalAmount"] = this.totalAmount;
        data["paymentStatus"] = this.paymentStatus;
        data["paymentMethod"] = this.paymentMethod;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["abpUserId"] = this.abpUserId;
        return data;
    }

    clone(): CreateUpdateBillingDto {
        const json = this.toJSON();
        let result = new CreateUpdateBillingDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateBillingDto {
    id: number;
    tenantId: number;
    patientId: number;
    billDate: moment.Moment;
    admissionDate: moment.Moment;
    dateOfSurgery: moment.Moment;
    totalAmount: number;
    paymentStatus: PaymentStatus;
    paymentMethod: string | undefined;
    items: BillItemDto[] | undefined;
    abpUserId: number;
}

export class CreateUpdateDepartmentDto implements ICreateUpdateDepartmentDto {
    id: number;
    tenantId: number;
    name: string | undefined;

    constructor(data?: ICreateUpdateDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateUpdateDepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateDepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        return data;
    }

    clone(): CreateUpdateDepartmentDto {
        const json = this.toJSON();
        let result = new CreateUpdateDepartmentDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateDepartmentDto {
    id: number;
    tenantId: number;
    name: string | undefined;
}

export class CreateUpdateDepositDto implements ICreateUpdateDepositDto {
    id: number;
    tenantId: number;
    patientId: number;
    amount: number;
    paymentMethod: PaymentMethod;
    billingMethod: BillingMethod;
    depositDateTime: moment.Moment;

    constructor(data?: ICreateUpdateDepositDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.patientId = _data["patientId"];
            this.amount = _data["amount"];
            this.paymentMethod = _data["paymentMethod"];
            this.billingMethod = _data["billingMethod"];
            this.depositDateTime = _data["depositDateTime"] ? moment(_data["depositDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUpdateDepositDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateDepositDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["patientId"] = this.patientId;
        data["amount"] = this.amount;
        data["paymentMethod"] = this.paymentMethod;
        data["billingMethod"] = this.billingMethod;
        data["depositDateTime"] = this.depositDateTime ? this.depositDateTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): CreateUpdateDepositDto {
        const json = this.toJSON();
        let result = new CreateUpdateDepositDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateDepositDto {
    id: number;
    tenantId: number;
    patientId: number;
    amount: number;
    paymentMethod: PaymentMethod;
    billingMethod: BillingMethod;
    depositDateTime: moment.Moment;
}

export class CreateUpdateDoctorDto implements ICreateUpdateDoctorDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    specialization: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    department: string | undefined;
    registrationNumber: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    abpUserId: number;

    constructor(data?: ICreateUpdateDoctorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.specialization = _data["specialization"];
            this.qualification = _data["qualification"];
            this.yearsOfExperience = _data["yearsOfExperience"];
            this.department = _data["department"];
            this.registrationNumber = _data["registrationNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.abpUserId = _data["abpUserId"];
        }
    }

    static fromJS(data: any): CreateUpdateDoctorDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateDoctorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["specialization"] = this.specialization;
        data["qualification"] = this.qualification;
        data["yearsOfExperience"] = this.yearsOfExperience;
        data["department"] = this.department;
        data["registrationNumber"] = this.registrationNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["abpUserId"] = this.abpUserId;
        return data;
    }

    clone(): CreateUpdateDoctorDto {
        const json = this.toJSON();
        let result = new CreateUpdateDoctorDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateDoctorDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    specialization: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    department: string | undefined;
    registrationNumber: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    abpUserId: number;
}

export class CreateUpdateDoctorMasterDto implements ICreateUpdateDoctorMasterDto {
    id: number;
    tenantId: number;
    doctorId: number;
    fee: number;

    constructor(data?: ICreateUpdateDoctorMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.doctorId = _data["doctorId"];
            this.fee = _data["fee"];
        }
    }

    static fromJS(data: any): CreateUpdateDoctorMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateDoctorMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["doctorId"] = this.doctorId;
        data["fee"] = this.fee;
        return data;
    }

    clone(): CreateUpdateDoctorMasterDto {
        const json = this.toJSON();
        let result = new CreateUpdateDoctorMasterDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateDoctorMasterDto {
    id: number;
    tenantId: number;
    doctorId: number;
    fee: number;
}

export class CreateUpdateInvoiceDto implements ICreateUpdateInvoiceDto {
    id: number;
    tenantId: number;
    patientId: number;
    appointmentId: number;
    invoiceDate: moment.Moment;
    dueDate: moment.Moment;
    subTotal: number;
    gstAmount: number;
    totalAmount: number;
    amountPaid: number;
    status: InvoiceStatus;
    paymentMethod: PaymentMethod;
    items: InvoiceItemDto[] | undefined;

    constructor(data?: ICreateUpdateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.patientId = _data["patientId"];
            this.appointmentId = _data["appointmentId"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.dueDate = _data["dueDate"] ? moment(_data["dueDate"].toString()) : <any>undefined;
            this.subTotal = _data["subTotal"];
            this.gstAmount = _data["gstAmount"];
            this.totalAmount = _data["totalAmount"];
            this.amountPaid = _data["amountPaid"];
            this.status = _data["status"];
            this.paymentMethod = _data["paymentMethod"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(InvoiceItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateUpdateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["patientId"] = this.patientId;
        data["appointmentId"] = this.appointmentId;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["subTotal"] = this.subTotal;
        data["gstAmount"] = this.gstAmount;
        data["totalAmount"] = this.totalAmount;
        data["amountPaid"] = this.amountPaid;
        data["status"] = this.status;
        data["paymentMethod"] = this.paymentMethod;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateUpdateInvoiceDto {
        const json = this.toJSON();
        let result = new CreateUpdateInvoiceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateInvoiceDto {
    id: number;
    tenantId: number;
    patientId: number;
    appointmentId: number;
    invoiceDate: moment.Moment;
    dueDate: moment.Moment;
    subTotal: number;
    gstAmount: number;
    totalAmount: number;
    amountPaid: number;
    status: InvoiceStatus;
    paymentMethod: PaymentMethod;
    items: InvoiceItemDto[] | undefined;
}

export class CreateUpdateLabReportResultItemDto implements ICreateUpdateLabReportResultItemDto {
    id: number;
    test: string | undefined;
    result: number;
    minValue: number;
    maxValue: number;
    unit: string | undefined;
    flag: string | undefined;
    prescriptionLabTestId: number;

    constructor(data?: ICreateUpdateLabReportResultItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.test = _data["test"];
            this.result = _data["result"];
            this.minValue = _data["minValue"];
            this.maxValue = _data["maxValue"];
            this.unit = _data["unit"];
            this.flag = _data["flag"];
            this.prescriptionLabTestId = _data["prescriptionLabTestId"];
        }
    }

    static fromJS(data: any): CreateUpdateLabReportResultItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateLabReportResultItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["test"] = this.test;
        data["result"] = this.result;
        data["minValue"] = this.minValue;
        data["maxValue"] = this.maxValue;
        data["unit"] = this.unit;
        data["flag"] = this.flag;
        data["prescriptionLabTestId"] = this.prescriptionLabTestId;
        return data;
    }

    clone(): CreateUpdateLabReportResultItemDto {
        const json = this.toJSON();
        let result = new CreateUpdateLabReportResultItemDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateLabReportResultItemDto {
    id: number;
    test: string | undefined;
    result: number;
    minValue: number;
    maxValue: number;
    unit: string | undefined;
    flag: string | undefined;
    prescriptionLabTestId: number;
}

export class CreateUpdateLabReportTypeDto implements ICreateUpdateLabReportTypeDto {
    id: number;
    tenantId: number;
    reportType: string | undefined;
    reportPrice: number;

    constructor(data?: ICreateUpdateLabReportTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.reportType = _data["reportType"];
            this.reportPrice = _data["reportPrice"];
        }
    }

    static fromJS(data: any): CreateUpdateLabReportTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateLabReportTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["reportType"] = this.reportType;
        data["reportPrice"] = this.reportPrice;
        return data;
    }

    clone(): CreateUpdateLabReportTypeDto {
        const json = this.toJSON();
        let result = new CreateUpdateLabReportTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateLabReportTypeDto {
    id: number;
    tenantId: number;
    reportType: string | undefined;
    reportPrice: number;
}

export class CreateUpdateLabRequestDto implements ICreateUpdateLabRequestDto {
    id: number;
    tenantId: number;
    prescriptionId: number;
    labReportsTypeId: number;
    testStatus: LabTestStatus;

    constructor(data?: ICreateUpdateLabRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.prescriptionId = _data["prescriptionId"];
            this.labReportsTypeId = _data["labReportsTypeId"];
            this.testStatus = _data["testStatus"];
        }
    }

    static fromJS(data: any): CreateUpdateLabRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateLabRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["prescriptionId"] = this.prescriptionId;
        data["labReportsTypeId"] = this.labReportsTypeId;
        data["testStatus"] = this.testStatus;
        return data;
    }

    clone(): CreateUpdateLabRequestDto {
        const json = this.toJSON();
        let result = new CreateUpdateLabRequestDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateLabRequestDto {
    id: number;
    tenantId: number;
    prescriptionId: number;
    labReportsTypeId: number;
    testStatus: LabTestStatus;
}

export class CreateUpdateLabTechnicianDto implements ICreateUpdateLabTechnicianDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    department: LabDepartment;
    certificationNumber: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    abpUserId: number;

    constructor(data?: ICreateUpdateLabTechnicianDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.qualification = _data["qualification"];
            this.yearsOfExperience = _data["yearsOfExperience"];
            this.department = _data["department"];
            this.certificationNumber = _data["certificationNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.abpUserId = _data["abpUserId"];
        }
    }

    static fromJS(data: any): CreateUpdateLabTechnicianDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateLabTechnicianDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["qualification"] = this.qualification;
        data["yearsOfExperience"] = this.yearsOfExperience;
        data["department"] = this.department;
        data["certificationNumber"] = this.certificationNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["abpUserId"] = this.abpUserId;
        return data;
    }

    clone(): CreateUpdateLabTechnicianDto {
        const json = this.toJSON();
        let result = new CreateUpdateLabTechnicianDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateLabTechnicianDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    department: LabDepartment;
    certificationNumber: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    abpUserId: number;
}

export class CreateUpdateMedicineOrderDto implements ICreateUpdateMedicineOrderDto {
    id: number;
    tenantId: number;
    nurseId: number;
    patientId: number | undefined;
    priority: string | undefined;
    nurse: NurseDto;
    patient: PatientDto;
    items: CreateUpdateMedicineOrderItemDto[] | undefined;

    constructor(data?: ICreateUpdateMedicineOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.nurseId = _data["nurseId"];
            this.patientId = _data["patientId"];
            this.priority = _data["priority"];
            this.nurse = _data["nurse"] ? NurseDto.fromJS(_data["nurse"]) : <any>undefined;
            this.patient = _data["patient"] ? PatientDto.fromJS(_data["patient"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CreateUpdateMedicineOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateUpdateMedicineOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateMedicineOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["nurseId"] = this.nurseId;
        data["patientId"] = this.patientId;
        data["priority"] = this.priority;
        data["nurse"] = this.nurse ? this.nurse.toJSON() : <any>undefined;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateUpdateMedicineOrderDto {
        const json = this.toJSON();
        let result = new CreateUpdateMedicineOrderDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateMedicineOrderDto {
    id: number;
    tenantId: number;
    nurseId: number;
    patientId: number | undefined;
    priority: string | undefined;
    nurse: NurseDto;
    patient: PatientDto;
    items: CreateUpdateMedicineOrderItemDto[] | undefined;
}

export class CreateUpdateMedicineOrderItemDto implements ICreateUpdateMedicineOrderItemDto {
    id: number;
    medicineId: number;
    quantity: number;
    dosage: string | undefined;

    constructor(data?: ICreateUpdateMedicineOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.medicineId = _data["medicineId"];
            this.quantity = _data["quantity"];
            this.dosage = _data["dosage"];
        }
    }

    static fromJS(data: any): CreateUpdateMedicineOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateMedicineOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["medicineId"] = this.medicineId;
        data["quantity"] = this.quantity;
        data["dosage"] = this.dosage;
        return data;
    }

    clone(): CreateUpdateMedicineOrderItemDto {
        const json = this.toJSON();
        let result = new CreateUpdateMedicineOrderItemDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateMedicineOrderItemDto {
    id: number;
    medicineId: number;
    quantity: number;
    dosage: string | undefined;
}

export class CreateUpdateNurseDto implements ICreateUpdateNurseDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    shiftTiming: string | undefined;
    department: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    dateOfBirth: moment.Moment | undefined;
    abpUserId: number;

    constructor(data?: ICreateUpdateNurseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.shiftTiming = _data["shiftTiming"];
            this.department = _data["department"];
            this.qualification = _data["qualification"];
            this.yearsOfExperience = _data["yearsOfExperience"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.abpUserId = _data["abpUserId"];
        }
    }

    static fromJS(data: any): CreateUpdateNurseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateNurseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["shiftTiming"] = this.shiftTiming;
        data["department"] = this.department;
        data["qualification"] = this.qualification;
        data["yearsOfExperience"] = this.yearsOfExperience;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["abpUserId"] = this.abpUserId;
        return data;
    }

    clone(): CreateUpdateNurseDto {
        const json = this.toJSON();
        let result = new CreateUpdateNurseDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateNurseDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    shiftTiming: string | undefined;
    department: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    dateOfBirth: moment.Moment | undefined;
    abpUserId: number;
}

export class CreateUpdatePatientDto implements ICreateUpdatePatientDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    dateOfBirth: moment.Moment;
    gender: string | undefined;
    address: string | undefined;
    bloodGroup: string | undefined;
    emergencyContactName: string | undefined;
    emergencyContactNumber: string | undefined;
    admissionDate: moment.Moment | undefined;
    abpUserId: number;

    constructor(data?: ICreateUpdatePatientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.address = _data["address"];
            this.bloodGroup = _data["bloodGroup"];
            this.emergencyContactName = _data["emergencyContactName"];
            this.emergencyContactNumber = _data["emergencyContactNumber"];
            this.admissionDate = _data["admissionDate"] ? moment(_data["admissionDate"].toString()) : <any>undefined;
            this.abpUserId = _data["abpUserId"];
        }
    }

    static fromJS(data: any): CreateUpdatePatientDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdatePatientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["address"] = this.address;
        data["bloodGroup"] = this.bloodGroup;
        data["emergencyContactName"] = this.emergencyContactName;
        data["emergencyContactNumber"] = this.emergencyContactNumber;
        data["admissionDate"] = this.admissionDate ? this.admissionDate.toISOString() : <any>undefined;
        data["abpUserId"] = this.abpUserId;
        return data;
    }

    clone(): CreateUpdatePatientDto {
        const json = this.toJSON();
        let result = new CreateUpdatePatientDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdatePatientDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    dateOfBirth: moment.Moment;
    gender: string | undefined;
    address: string | undefined;
    bloodGroup: string | undefined;
    emergencyContactName: string | undefined;
    emergencyContactNumber: string | undefined;
    admissionDate: moment.Moment | undefined;
    abpUserId: number;
}

export class CreateUpdatePharmacistDto implements ICreateUpdatePharmacistDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    qualification: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    licenseNumber: string | undefined;
    licenseExpiryDate: moment.Moment;
    abpUserId: number;

    constructor(data?: ICreateUpdatePharmacistDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.qualification = _data["qualification"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.licenseNumber = _data["licenseNumber"];
            this.licenseExpiryDate = _data["licenseExpiryDate"] ? moment(_data["licenseExpiryDate"].toString()) : <any>undefined;
            this.abpUserId = _data["abpUserId"];
        }
    }

    static fromJS(data: any): CreateUpdatePharmacistDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdatePharmacistDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["qualification"] = this.qualification;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["licenseNumber"] = this.licenseNumber;
        data["licenseExpiryDate"] = this.licenseExpiryDate ? this.licenseExpiryDate.toISOString() : <any>undefined;
        data["abpUserId"] = this.abpUserId;
        return data;
    }

    clone(): CreateUpdatePharmacistDto {
        const json = this.toJSON();
        let result = new CreateUpdatePharmacistDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdatePharmacistDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    qualification: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    licenseNumber: string | undefined;
    licenseExpiryDate: moment.Moment;
    abpUserId: number;
}

export class CreateUpdatePharmacistInventoryDto implements ICreateUpdatePharmacistInventoryDto {
    id: number;
    tenantId: number;
    medicineName: string | undefined;
    costPrice: number;
    sellingPrice: number;
    expiryDate: moment.Moment;
    purchaseDate: moment.Moment;
    unit: string | undefined;
    stock: number;
    minStock: number;
    description: string | undefined;
    isAvailable: boolean;

    constructor(data?: ICreateUpdatePharmacistInventoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.medicineName = _data["medicineName"];
            this.costPrice = _data["costPrice"];
            this.sellingPrice = _data["sellingPrice"];
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.purchaseDate = _data["purchaseDate"] ? moment(_data["purchaseDate"].toString()) : <any>undefined;
            this.unit = _data["unit"];
            this.stock = _data["stock"];
            this.minStock = _data["minStock"];
            this.description = _data["description"];
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): CreateUpdatePharmacistInventoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdatePharmacistInventoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["medicineName"] = this.medicineName;
        data["costPrice"] = this.costPrice;
        data["sellingPrice"] = this.sellingPrice;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toISOString() : <any>undefined;
        data["unit"] = this.unit;
        data["stock"] = this.stock;
        data["minStock"] = this.minStock;
        data["description"] = this.description;
        data["isAvailable"] = this.isAvailable;
        return data;
    }

    clone(): CreateUpdatePharmacistInventoryDto {
        const json = this.toJSON();
        let result = new CreateUpdatePharmacistInventoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdatePharmacistInventoryDto {
    id: number;
    tenantId: number;
    medicineName: string | undefined;
    costPrice: number;
    sellingPrice: number;
    expiryDate: moment.Moment;
    purchaseDate: moment.Moment;
    unit: string | undefined;
    stock: number;
    minStock: number;
    description: string | undefined;
    isAvailable: boolean;
}

export class CreateUpdatePrescriptionDto implements ICreateUpdatePrescriptionDto {
    id: number;
    tenantId: number;
    diagnosis: string | undefined;
    notes: string | undefined;
    issueDate: moment.Moment;
    isFollowUpRequired: boolean;
    appointmentId: number;
    doctorId: number;
    patientId: number;
    labTestIds: number[] | undefined;
    items: CreateUpdatePrescriptionItemDto[] | undefined;

    constructor(data?: ICreateUpdatePrescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.diagnosis = _data["diagnosis"];
            this.notes = _data["notes"];
            this.issueDate = _data["issueDate"] ? moment(_data["issueDate"].toString()) : <any>undefined;
            this.isFollowUpRequired = _data["isFollowUpRequired"];
            this.appointmentId = _data["appointmentId"];
            this.doctorId = _data["doctorId"];
            this.patientId = _data["patientId"];
            if (Array.isArray(_data["labTestIds"])) {
                this.labTestIds = [] as any;
                for (let item of _data["labTestIds"])
                    this.labTestIds.push(item);
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CreateUpdatePrescriptionItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateUpdatePrescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdatePrescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["diagnosis"] = this.diagnosis;
        data["notes"] = this.notes;
        data["issueDate"] = this.issueDate ? this.issueDate.toISOString() : <any>undefined;
        data["isFollowUpRequired"] = this.isFollowUpRequired;
        data["appointmentId"] = this.appointmentId;
        data["doctorId"] = this.doctorId;
        data["patientId"] = this.patientId;
        if (Array.isArray(this.labTestIds)) {
            data["labTestIds"] = [];
            for (let item of this.labTestIds)
                data["labTestIds"].push(item);
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateUpdatePrescriptionDto {
        const json = this.toJSON();
        let result = new CreateUpdatePrescriptionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdatePrescriptionDto {
    id: number;
    tenantId: number;
    diagnosis: string | undefined;
    notes: string | undefined;
    issueDate: moment.Moment;
    isFollowUpRequired: boolean;
    appointmentId: number;
    doctorId: number;
    patientId: number;
    labTestIds: number[] | undefined;
    items: CreateUpdatePrescriptionItemDto[] | undefined;
}

export class CreateUpdatePrescriptionItemDto implements ICreateUpdatePrescriptionItemDto {
    id: number;
    tenantId: number;
    medicineName: string | undefined;
    dosage: string | undefined;
    frequency: string | undefined;
    duration: string | undefined;
    instructions: string | undefined;
    prescriptionId: number;
    medicineId: number;

    constructor(data?: ICreateUpdatePrescriptionItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.medicineName = _data["medicineName"];
            this.dosage = _data["dosage"];
            this.frequency = _data["frequency"];
            this.duration = _data["duration"];
            this.instructions = _data["instructions"];
            this.prescriptionId = _data["prescriptionId"];
            this.medicineId = _data["medicineId"];
        }
    }

    static fromJS(data: any): CreateUpdatePrescriptionItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdatePrescriptionItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["medicineName"] = this.medicineName;
        data["dosage"] = this.dosage;
        data["frequency"] = this.frequency;
        data["duration"] = this.duration;
        data["instructions"] = this.instructions;
        data["prescriptionId"] = this.prescriptionId;
        data["medicineId"] = this.medicineId;
        return data;
    }

    clone(): CreateUpdatePrescriptionItemDto {
        const json = this.toJSON();
        let result = new CreateUpdatePrescriptionItemDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdatePrescriptionItemDto {
    id: number;
    tenantId: number;
    medicineName: string | undefined;
    dosage: string | undefined;
    frequency: string | undefined;
    duration: string | undefined;
    instructions: string | undefined;
    prescriptionId: number;
    medicineId: number;
}

export class CreateUpdateRoomDto implements ICreateUpdateRoomDto {
    id: number;
    tenantId: number;
    roomNumber: string | undefined;
    floor: number;
    roomTypeMasterId: number;
    status: RoomStatus;

    constructor(data?: ICreateUpdateRoomDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.roomNumber = _data["roomNumber"];
            this.floor = _data["floor"];
            this.roomTypeMasterId = _data["roomTypeMasterId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CreateUpdateRoomDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateRoomDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["roomNumber"] = this.roomNumber;
        data["floor"] = this.floor;
        data["roomTypeMasterId"] = this.roomTypeMasterId;
        data["status"] = this.status;
        return data;
    }

    clone(): CreateUpdateRoomDto {
        const json = this.toJSON();
        let result = new CreateUpdateRoomDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateRoomDto {
    id: number;
    tenantId: number;
    roomNumber: string | undefined;
    floor: number;
    roomTypeMasterId: number;
    status: RoomStatus;
}

export class CreateUpdateRoomFacilityMasterDto implements ICreateUpdateRoomFacilityMasterDto {
    id: number;
    tenantId: number;
    facilityName: string | undefined;

    constructor(data?: ICreateUpdateRoomFacilityMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.facilityName = _data["facilityName"];
        }
    }

    static fromJS(data: any): CreateUpdateRoomFacilityMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateRoomFacilityMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["facilityName"] = this.facilityName;
        return data;
    }

    clone(): CreateUpdateRoomFacilityMasterDto {
        const json = this.toJSON();
        let result = new CreateUpdateRoomFacilityMasterDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateRoomFacilityMasterDto {
    id: number;
    tenantId: number;
    facilityName: string | undefined;
}

export class CreateUpdateRoomTypeMasterDto implements ICreateUpdateRoomTypeMasterDto {
    id: number;
    tenantId: number;
    typeName: string | undefined;
    description: string | undefined;
    defaultPricePerDay: number;
    facilityIds: number[] | undefined;

    constructor(data?: ICreateUpdateRoomTypeMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.typeName = _data["typeName"];
            this.description = _data["description"];
            this.defaultPricePerDay = _data["defaultPricePerDay"];
            if (Array.isArray(_data["facilityIds"])) {
                this.facilityIds = [] as any;
                for (let item of _data["facilityIds"])
                    this.facilityIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUpdateRoomTypeMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateRoomTypeMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["typeName"] = this.typeName;
        data["description"] = this.description;
        data["defaultPricePerDay"] = this.defaultPricePerDay;
        if (Array.isArray(this.facilityIds)) {
            data["facilityIds"] = [];
            for (let item of this.facilityIds)
                data["facilityIds"].push(item);
        }
        return data;
    }

    clone(): CreateUpdateRoomTypeMasterDto {
        const json = this.toJSON();
        let result = new CreateUpdateRoomTypeMasterDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateRoomTypeMasterDto {
    id: number;
    tenantId: number;
    typeName: string | undefined;
    description: string | undefined;
    defaultPricePerDay: number;
    facilityIds: number[] | undefined;
}

export class CreateUpdateVisitDto implements ICreateUpdateVisitDto {
    id: number;
    tenantId: number;
    patientId: number;
    departmentId: number;
    doctorId: number;
    nurseId: number;
    dateOfVisit: moment.Moment;
    timeOfVisit: string;
    reasonForVisit: string | undefined;
    paymentMode: PaymentMode;
    consultationFee: number | undefined;

    constructor(data?: ICreateUpdateVisitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.patientId = _data["patientId"];
            this.departmentId = _data["departmentId"];
            this.doctorId = _data["doctorId"];
            this.nurseId = _data["nurseId"];
            this.dateOfVisit = _data["dateOfVisit"] ? moment(_data["dateOfVisit"].toString()) : <any>undefined;
            this.timeOfVisit = _data["timeOfVisit"];
            this.reasonForVisit = _data["reasonForVisit"];
            this.paymentMode = _data["paymentMode"];
            this.consultationFee = _data["consultationFee"];
        }
    }

    static fromJS(data: any): CreateUpdateVisitDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateVisitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["patientId"] = this.patientId;
        data["departmentId"] = this.departmentId;
        data["doctorId"] = this.doctorId;
        data["nurseId"] = this.nurseId;
        data["dateOfVisit"] = this.dateOfVisit ? this.dateOfVisit.toISOString() : <any>undefined;
        data["timeOfVisit"] = this.timeOfVisit;
        data["reasonForVisit"] = this.reasonForVisit;
        data["paymentMode"] = this.paymentMode;
        data["consultationFee"] = this.consultationFee;
        return data;
    }

    clone(): CreateUpdateVisitDto {
        const json = this.toJSON();
        let result = new CreateUpdateVisitDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateVisitDto {
    id: number;
    tenantId: number;
    patientId: number;
    departmentId: number;
    doctorId: number;
    nurseId: number;
    dateOfVisit: moment.Moment;
    timeOfVisit: string;
    reasonForVisit: string | undefined;
    paymentMode: PaymentMode;
    consultationFee: number | undefined;
}

export class CreateUpdateVitalDto implements ICreateUpdateVitalDto {
    id: number;
    tenantId: number;
    dateRecorded: moment.Moment | undefined;
    bloodPressure: string | undefined;
    heartRate: string | undefined;
    respirationRate: number;
    temperature: number;
    oxygenSaturation: number;
    height: string | undefined;
    weight: string | undefined;
    bmi: string | undefined;
    notes: string | undefined;
    patientId: number;
    nurseId: number;

    constructor(data?: ICreateUpdateVitalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.dateRecorded = _data["dateRecorded"] ? moment(_data["dateRecorded"].toString()) : <any>undefined;
            this.bloodPressure = _data["bloodPressure"];
            this.heartRate = _data["heartRate"];
            this.respirationRate = _data["respirationRate"];
            this.temperature = _data["temperature"];
            this.oxygenSaturation = _data["oxygenSaturation"];
            this.height = _data["height"];
            this.weight = _data["weight"];
            this.bmi = _data["bmi"];
            this.notes = _data["notes"];
            this.patientId = _data["patientId"];
            this.nurseId = _data["nurseId"];
        }
    }

    static fromJS(data: any): CreateUpdateVitalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateVitalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["dateRecorded"] = this.dateRecorded ? this.dateRecorded.toISOString() : <any>undefined;
        data["bloodPressure"] = this.bloodPressure;
        data["heartRate"] = this.heartRate;
        data["respirationRate"] = this.respirationRate;
        data["temperature"] = this.temperature;
        data["oxygenSaturation"] = this.oxygenSaturation;
        data["height"] = this.height;
        data["weight"] = this.weight;
        data["bmi"] = this.bmi;
        data["notes"] = this.notes;
        data["patientId"] = this.patientId;
        data["nurseId"] = this.nurseId;
        return data;
    }

    clone(): CreateUpdateVitalDto {
        const json = this.toJSON();
        let result = new CreateUpdateVitalDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateVitalDto {
    id: number;
    tenantId: number;
    dateRecorded: moment.Moment | undefined;
    bloodPressure: string | undefined;
    heartRate: string | undefined;
    respirationRate: number;
    temperature: number;
    oxygenSaturation: number;
    height: string | undefined;
    weight: string | undefined;
    bmi: string | undefined;
    notes: string | undefined;
    patientId: number;
    nurseId: number;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
}

export class Department implements IDepartment {
    id: number;
    tenantId: number;
    name: string | undefined;
    visits: Visit[] | undefined;

    constructor(data?: IDepartment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            if (Array.isArray(_data["visits"])) {
                this.visits = [] as any;
                for (let item of _data["visits"])
                    this.visits.push(Visit.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Department {
        data = typeof data === 'object' ? data : {};
        let result = new Department();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        if (Array.isArray(this.visits)) {
            data["visits"] = [];
            for (let item of this.visits)
                data["visits"].push(item.toJSON());
        }
        return data;
    }

    clone(): Department {
        const json = this.toJSON();
        let result = new Department();
        result.init(json);
        return result;
    }
}

export interface IDepartment {
    id: number;
    tenantId: number;
    name: string | undefined;
    visits: Visit[] | undefined;
}

export class DepartmentListDto implements IDepartmentListDto {
    id: number;
    tenantId: number;
    name: string | undefined;

    constructor(data?: IDepartmentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DepartmentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        return data;
    }

    clone(): DepartmentListDto {
        const json = this.toJSON();
        let result = new DepartmentListDto();
        result.init(json);
        return result;
    }
}

export interface IDepartmentListDto {
    id: number;
    tenantId: number;
    name: string | undefined;
}

export class DepartmentListDtoListResultDto implements IDepartmentListDtoListResultDto {
    items: DepartmentListDto[] | undefined;

    constructor(data?: IDepartmentListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DepartmentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DepartmentListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): DepartmentListDtoListResultDto {
        const json = this.toJSON();
        let result = new DepartmentListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IDepartmentListDtoListResultDto {
    items: DepartmentListDto[] | undefined;
}

export class DepartmentListDtoPagedResultDto implements IDepartmentListDtoPagedResultDto {
    items: DepartmentListDto[] | undefined;
    totalCount: number;

    constructor(data?: IDepartmentListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DepartmentListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DepartmentListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DepartmentListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DepartmentListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDepartmentListDtoPagedResultDto {
    items: DepartmentListDto[] | undefined;
    totalCount: number;
}

export class Deposit implements IDeposit {
    id: number;
    tenantId: number;
    patientId: number;
    amount: number;
    paymentMethod: PaymentMethod;
    billingMethod: BillingMethod;
    depositDateTime: moment.Moment;
    patient: Patient;

    constructor(data?: IDeposit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.patientId = _data["patientId"];
            this.amount = _data["amount"];
            this.paymentMethod = _data["paymentMethod"];
            this.billingMethod = _data["billingMethod"];
            this.depositDateTime = _data["depositDateTime"] ? moment(_data["depositDateTime"].toString()) : <any>undefined;
            this.patient = _data["patient"] ? Patient.fromJS(_data["patient"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Deposit {
        data = typeof data === 'object' ? data : {};
        let result = new Deposit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["patientId"] = this.patientId;
        data["amount"] = this.amount;
        data["paymentMethod"] = this.paymentMethod;
        data["billingMethod"] = this.billingMethod;
        data["depositDateTime"] = this.depositDateTime ? this.depositDateTime.toISOString() : <any>undefined;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>undefined;
        return data;
    }

    clone(): Deposit {
        const json = this.toJSON();
        let result = new Deposit();
        result.init(json);
        return result;
    }
}

export interface IDeposit {
    id: number;
    tenantId: number;
    patientId: number;
    amount: number;
    paymentMethod: PaymentMethod;
    billingMethod: BillingMethod;
    depositDateTime: moment.Moment;
    patient: Patient;
}

export class DepositDto implements IDepositDto {
    id: number;
    tenantId: number;
    patientId: number;
    patientName: string | undefined;
    amount: number;
    paymentMethod: PaymentMethod;
    billingMethod: BillingMethod;
    depositDateTime: moment.Moment;

    constructor(data?: IDepositDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.patientId = _data["patientId"];
            this.patientName = _data["patientName"];
            this.amount = _data["amount"];
            this.paymentMethod = _data["paymentMethod"];
            this.billingMethod = _data["billingMethod"];
            this.depositDateTime = _data["depositDateTime"] ? moment(_data["depositDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DepositDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepositDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["patientId"] = this.patientId;
        data["patientName"] = this.patientName;
        data["amount"] = this.amount;
        data["paymentMethod"] = this.paymentMethod;
        data["billingMethod"] = this.billingMethod;
        data["depositDateTime"] = this.depositDateTime ? this.depositDateTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): DepositDto {
        const json = this.toJSON();
        let result = new DepositDto();
        result.init(json);
        return result;
    }
}

export interface IDepositDto {
    id: number;
    tenantId: number;
    patientId: number;
    patientName: string | undefined;
    amount: number;
    paymentMethod: PaymentMethod;
    billingMethod: BillingMethod;
    depositDateTime: moment.Moment;
}

export class DepositDtoPagedResultDto implements IDepositDtoPagedResultDto {
    items: DepositDto[] | undefined;
    totalCount: number;

    constructor(data?: IDepositDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DepositDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DepositDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepositDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DepositDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DepositDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDepositDtoPagedResultDto {
    items: DepositDto[] | undefined;
    totalCount: number;
}

export class DepositResponseDto implements IDepositResponseDto {
    deposit: DepositDto;
    stripeRedirectUrl: string | undefined;

    constructor(data?: IDepositResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deposit = _data["deposit"] ? DepositDto.fromJS(_data["deposit"]) : <any>undefined;
            this.stripeRedirectUrl = _data["stripeRedirectUrl"];
        }
    }

    static fromJS(data: any): DepositResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepositResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deposit"] = this.deposit ? this.deposit.toJSON() : <any>undefined;
        data["stripeRedirectUrl"] = this.stripeRedirectUrl;
        return data;
    }

    clone(): DepositResponseDto {
        const json = this.toJSON();
        let result = new DepositResponseDto();
        result.init(json);
        return result;
    }
}

export interface IDepositResponseDto {
    deposit: DepositDto;
    stripeRedirectUrl: string | undefined;
}

export class Doctor implements IDoctor {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    specialization: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    department: string | undefined;
    registrationNumber: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    abpUserId: number;
    abpUser: User;
    prescriptions: Prescription[] | undefined;
    appointments: Appointment[] | undefined;
    admissions: Admission[] | undefined;
    visits: Visit[] | undefined;

    constructor(data?: IDoctor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.specialization = _data["specialization"];
            this.qualification = _data["qualification"];
            this.yearsOfExperience = _data["yearsOfExperience"];
            this.department = _data["department"];
            this.registrationNumber = _data["registrationNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.abpUserId = _data["abpUserId"];
            this.abpUser = _data["abpUser"] ? User.fromJS(_data["abpUser"]) : <any>undefined;
            if (Array.isArray(_data["prescriptions"])) {
                this.prescriptions = [] as any;
                for (let item of _data["prescriptions"])
                    this.prescriptions.push(Prescription.fromJS(item));
            }
            if (Array.isArray(_data["appointments"])) {
                this.appointments = [] as any;
                for (let item of _data["appointments"])
                    this.appointments.push(Appointment.fromJS(item));
            }
            if (Array.isArray(_data["admissions"])) {
                this.admissions = [] as any;
                for (let item of _data["admissions"])
                    this.admissions.push(Admission.fromJS(item));
            }
            if (Array.isArray(_data["visits"])) {
                this.visits = [] as any;
                for (let item of _data["visits"])
                    this.visits.push(Visit.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Doctor {
        data = typeof data === 'object' ? data : {};
        let result = new Doctor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["specialization"] = this.specialization;
        data["qualification"] = this.qualification;
        data["yearsOfExperience"] = this.yearsOfExperience;
        data["department"] = this.department;
        data["registrationNumber"] = this.registrationNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["abpUserId"] = this.abpUserId;
        data["abpUser"] = this.abpUser ? this.abpUser.toJSON() : <any>undefined;
        if (Array.isArray(this.prescriptions)) {
            data["prescriptions"] = [];
            for (let item of this.prescriptions)
                data["prescriptions"].push(item.toJSON());
        }
        if (Array.isArray(this.appointments)) {
            data["appointments"] = [];
            for (let item of this.appointments)
                data["appointments"].push(item.toJSON());
        }
        if (Array.isArray(this.admissions)) {
            data["admissions"] = [];
            for (let item of this.admissions)
                data["admissions"].push(item.toJSON());
        }
        if (Array.isArray(this.visits)) {
            data["visits"] = [];
            for (let item of this.visits)
                data["visits"].push(item.toJSON());
        }
        return data;
    }

    clone(): Doctor {
        const json = this.toJSON();
        let result = new Doctor();
        result.init(json);
        return result;
    }
}

export interface IDoctor {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    specialization: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    department: string | undefined;
    registrationNumber: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    abpUserId: number;
    abpUser: User;
    prescriptions: Prescription[] | undefined;
    appointments: Appointment[] | undefined;
    admissions: Admission[] | undefined;
    visits: Visit[] | undefined;
}

export class DoctorDto implements IDoctorDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    specialization: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    department: string | undefined;
    registrationNumber: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    abpUser: UserDto;
    prescriptions: PrescriptionDto[] | undefined;

    constructor(data?: IDoctorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.specialization = _data["specialization"];
            this.qualification = _data["qualification"];
            this.yearsOfExperience = _data["yearsOfExperience"];
            this.department = _data["department"];
            this.registrationNumber = _data["registrationNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.abpUser = _data["abpUser"] ? UserDto.fromJS(_data["abpUser"]) : <any>undefined;
            if (Array.isArray(_data["prescriptions"])) {
                this.prescriptions = [] as any;
                for (let item of _data["prescriptions"])
                    this.prescriptions.push(PrescriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DoctorDto {
        data = typeof data === 'object' ? data : {};
        let result = new DoctorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["specialization"] = this.specialization;
        data["qualification"] = this.qualification;
        data["yearsOfExperience"] = this.yearsOfExperience;
        data["department"] = this.department;
        data["registrationNumber"] = this.registrationNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["abpUser"] = this.abpUser ? this.abpUser.toJSON() : <any>undefined;
        if (Array.isArray(this.prescriptions)) {
            data["prescriptions"] = [];
            for (let item of this.prescriptions)
                data["prescriptions"].push(item.toJSON());
        }
        return data;
    }

    clone(): DoctorDto {
        const json = this.toJSON();
        let result = new DoctorDto();
        result.init(json);
        return result;
    }
}

export interface IDoctorDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    specialization: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    department: string | undefined;
    registrationNumber: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    abpUser: UserDto;
    prescriptions: PrescriptionDto[] | undefined;
}

export class DoctorDtoListResultDto implements IDoctorDtoListResultDto {
    items: DoctorDto[] | undefined;

    constructor(data?: IDoctorDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DoctorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DoctorDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DoctorDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): DoctorDtoListResultDto {
        const json = this.toJSON();
        let result = new DoctorDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IDoctorDtoListResultDto {
    items: DoctorDto[] | undefined;
}

export class DoctorDtoPagedResultDto implements IDoctorDtoPagedResultDto {
    items: DoctorDto[] | undefined;
    totalCount: number;

    constructor(data?: IDoctorDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DoctorDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DoctorDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DoctorDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DoctorDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DoctorDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDoctorDtoPagedResultDto {
    items: DoctorDto[] | undefined;
    totalCount: number;
}

export class DoctorMasterDto implements IDoctorMasterDto {
    id: number;
    tenantId: number;
    doctorId: number;
    doctor: DoctorDto;
    fee: number;

    constructor(data?: IDoctorMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.doctorId = _data["doctorId"];
            this.doctor = _data["doctor"] ? DoctorDto.fromJS(_data["doctor"]) : <any>undefined;
            this.fee = _data["fee"];
        }
    }

    static fromJS(data: any): DoctorMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new DoctorMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["doctorId"] = this.doctorId;
        data["doctor"] = this.doctor ? this.doctor.toJSON() : <any>undefined;
        data["fee"] = this.fee;
        return data;
    }

    clone(): DoctorMasterDto {
        const json = this.toJSON();
        let result = new DoctorMasterDto();
        result.init(json);
        return result;
    }
}

export interface IDoctorMasterDto {
    id: number;
    tenantId: number;
    doctorId: number;
    doctor: DoctorDto;
    fee: number;
}

export class DoctorMasterDtoListResultDto implements IDoctorMasterDtoListResultDto {
    items: DoctorMasterDto[] | undefined;

    constructor(data?: IDoctorMasterDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DoctorMasterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DoctorMasterDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DoctorMasterDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): DoctorMasterDtoListResultDto {
        const json = this.toJSON();
        let result = new DoctorMasterDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IDoctorMasterDtoListResultDto {
    items: DoctorMasterDto[] | undefined;
}

export class DoctorMasterDtoPagedResultDto implements IDoctorMasterDtoPagedResultDto {
    items: DoctorMasterDto[] | undefined;
    totalCount: number;

    constructor(data?: IDoctorMasterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DoctorMasterDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DoctorMasterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DoctorMasterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DoctorMasterDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DoctorMasterDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDoctorMasterDtoPagedResultDto {
    items: DoctorMasterDto[] | undefined;
    totalCount: number;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class Int64EntityDto implements IInt64EntityDto {
    id: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): Int64EntityDto {
        const json = this.toJSON();
        let result = new Int64EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt64EntityDto {
    id: number;
}

export class InvoiceDetailsDto implements IInvoiceDetailsDto {
    appointmentId: number;
    appointmentDate: moment.Moment;
    patientName: string | undefined;
    doctorName: string | undefined;
    consultationFee: number;
    labTests: LabTestDetailDto[] | undefined;
    medicines: MedicineDetailDto[] | undefined;
    subTotal: number;
    gstAmount: number;
    totalAmount: number;

    constructor(data?: IInvoiceDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appointmentId = _data["appointmentId"];
            this.appointmentDate = _data["appointmentDate"] ? moment(_data["appointmentDate"].toString()) : <any>undefined;
            this.patientName = _data["patientName"];
            this.doctorName = _data["doctorName"];
            this.consultationFee = _data["consultationFee"];
            if (Array.isArray(_data["labTests"])) {
                this.labTests = [] as any;
                for (let item of _data["labTests"])
                    this.labTests.push(LabTestDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["medicines"])) {
                this.medicines = [] as any;
                for (let item of _data["medicines"])
                    this.medicines.push(MedicineDetailDto.fromJS(item));
            }
            this.subTotal = _data["subTotal"];
            this.gstAmount = _data["gstAmount"];
            this.totalAmount = _data["totalAmount"];
        }
    }

    static fromJS(data: any): InvoiceDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appointmentId"] = this.appointmentId;
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>undefined;
        data["patientName"] = this.patientName;
        data["doctorName"] = this.doctorName;
        data["consultationFee"] = this.consultationFee;
        if (Array.isArray(this.labTests)) {
            data["labTests"] = [];
            for (let item of this.labTests)
                data["labTests"].push(item.toJSON());
        }
        if (Array.isArray(this.medicines)) {
            data["medicines"] = [];
            for (let item of this.medicines)
                data["medicines"].push(item.toJSON());
        }
        data["subTotal"] = this.subTotal;
        data["gstAmount"] = this.gstAmount;
        data["totalAmount"] = this.totalAmount;
        return data;
    }

    clone(): InvoiceDetailsDto {
        const json = this.toJSON();
        let result = new InvoiceDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDetailsDto {
    appointmentId: number;
    appointmentDate: moment.Moment;
    patientName: string | undefined;
    doctorName: string | undefined;
    consultationFee: number;
    labTests: LabTestDetailDto[] | undefined;
    medicines: MedicineDetailDto[] | undefined;
    subTotal: number;
    gstAmount: number;
    totalAmount: number;
}

export class InvoiceDto implements IInvoiceDto {
    id: number;
    tenantId: number;
    patientId: number;
    patientName: string | undefined;
    appointmentId: number;
    appointmentDate: moment.Moment;
    invoiceDate: moment.Moment;
    dueDate: moment.Moment;
    subTotal: number;
    gstAmount: number;
    totalAmount: number;
    amountPaid: number;
    status: InvoiceStatus;
    paymentMethod: PaymentMethod;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.patientId = _data["patientId"];
            this.patientName = _data["patientName"];
            this.appointmentId = _data["appointmentId"];
            this.appointmentDate = _data["appointmentDate"] ? moment(_data["appointmentDate"].toString()) : <any>undefined;
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.dueDate = _data["dueDate"] ? moment(_data["dueDate"].toString()) : <any>undefined;
            this.subTotal = _data["subTotal"];
            this.gstAmount = _data["gstAmount"];
            this.totalAmount = _data["totalAmount"];
            this.amountPaid = _data["amountPaid"];
            this.status = _data["status"];
            this.paymentMethod = _data["paymentMethod"];
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["patientId"] = this.patientId;
        data["patientName"] = this.patientName;
        data["appointmentId"] = this.appointmentId;
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>undefined;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["subTotal"] = this.subTotal;
        data["gstAmount"] = this.gstAmount;
        data["totalAmount"] = this.totalAmount;
        data["amountPaid"] = this.amountPaid;
        data["status"] = this.status;
        data["paymentMethod"] = this.paymentMethod;
        return data;
    }

    clone(): InvoiceDto {
        const json = this.toJSON();
        let result = new InvoiceDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDto {
    id: number;
    tenantId: number;
    patientId: number;
    patientName: string | undefined;
    appointmentId: number;
    appointmentDate: moment.Moment;
    invoiceDate: moment.Moment;
    dueDate: moment.Moment;
    subTotal: number;
    gstAmount: number;
    totalAmount: number;
    amountPaid: number;
    status: InvoiceStatus;
    paymentMethod: PaymentMethod;
}

export class InvoiceDtoPagedResultDto implements IInvoiceDtoPagedResultDto {
    items: InvoiceDto[] | undefined;
    totalCount: number;

    constructor(data?: IInvoiceDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(InvoiceDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): InvoiceDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): InvoiceDtoPagedResultDto {
        const json = this.toJSON();
        let result = new InvoiceDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDtoPagedResultDto {
    items: InvoiceDto[] | undefined;
    totalCount: number;
}

export class InvoiceItemDto implements IInvoiceItemDto {
    id: number;
    invoiceId: number;
    itemType: InvoiceItemType;
    readonly itemTypeDisplay: string | undefined;
    description: string | undefined;
    quantity: number;
    unitPrice: number;
    totalPrice: number;

    constructor(data?: IInvoiceItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceId = _data["invoiceId"];
            this.itemType = _data["itemType"];
            (<any>this).itemTypeDisplay = _data["itemTypeDisplay"];
            this.description = _data["description"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
            this.totalPrice = _data["totalPrice"];
        }
    }

    static fromJS(data: any): InvoiceItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceId"] = this.invoiceId;
        data["itemType"] = this.itemType;
        data["itemTypeDisplay"] = this.itemTypeDisplay;
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["totalPrice"] = this.totalPrice;
        return data;
    }

    clone(): InvoiceItemDto {
        const json = this.toJSON();
        let result = new InvoiceItemDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceItemDto {
    id: number;
    invoiceId: number;
    itemType: InvoiceItemType;
    itemTypeDisplay: string | undefined;
    description: string | undefined;
    quantity: number;
    unitPrice: number;
    totalPrice: number;
}

export enum InvoiceItemType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum InvoiceStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export enum LabDepartment {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class LabOrderListDto implements ILabOrderListDto {
    id: number;
    patientName: string | undefined;
    gender: string | undefined;
    appointmentDate: moment.Moment;
    doctorName: string | undefined;
    labReportTypeName: string | undefined;
    testStatus: LabTestStatus;

    constructor(data?: ILabOrderListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.patientName = _data["patientName"];
            this.gender = _data["gender"];
            this.appointmentDate = _data["appointmentDate"] ? moment(_data["appointmentDate"].toString()) : <any>undefined;
            this.doctorName = _data["doctorName"];
            this.labReportTypeName = _data["labReportTypeName"];
            this.testStatus = _data["testStatus"];
        }
    }

    static fromJS(data: any): LabOrderListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LabOrderListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["patientName"] = this.patientName;
        data["gender"] = this.gender;
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>undefined;
        data["doctorName"] = this.doctorName;
        data["labReportTypeName"] = this.labReportTypeName;
        data["testStatus"] = this.testStatus;
        return data;
    }

    clone(): LabOrderListDto {
        const json = this.toJSON();
        let result = new LabOrderListDto();
        result.init(json);
        return result;
    }
}

export interface ILabOrderListDto {
    id: number;
    patientName: string | undefined;
    gender: string | undefined;
    appointmentDate: moment.Moment;
    doctorName: string | undefined;
    labReportTypeName: string | undefined;
    testStatus: LabTestStatus;
}

export class LabOrderListDtoPagedResultDto implements ILabOrderListDtoPagedResultDto {
    items: LabOrderListDto[] | undefined;
    totalCount: number;

    constructor(data?: ILabOrderListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LabOrderListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LabOrderListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LabOrderListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): LabOrderListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LabOrderListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILabOrderListDtoPagedResultDto {
    items: LabOrderListDto[] | undefined;
    totalCount: number;
}

export class LabReportResultItem implements ILabReportResultItem {
    id: number;
    test: string | undefined;
    result: number;
    minValue: number;
    maxValue: number;
    unit: string | undefined;
    flag: string | undefined;
    prescriptionLabTestId: number;
    prescriptionLabTest: PrescriptionLabTest;

    constructor(data?: ILabReportResultItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.test = _data["test"];
            this.result = _data["result"];
            this.minValue = _data["minValue"];
            this.maxValue = _data["maxValue"];
            this.unit = _data["unit"];
            this.flag = _data["flag"];
            this.prescriptionLabTestId = _data["prescriptionLabTestId"];
            this.prescriptionLabTest = _data["prescriptionLabTest"] ? PrescriptionLabTest.fromJS(_data["prescriptionLabTest"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LabReportResultItem {
        data = typeof data === 'object' ? data : {};
        let result = new LabReportResultItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["test"] = this.test;
        data["result"] = this.result;
        data["minValue"] = this.minValue;
        data["maxValue"] = this.maxValue;
        data["unit"] = this.unit;
        data["flag"] = this.flag;
        data["prescriptionLabTestId"] = this.prescriptionLabTestId;
        data["prescriptionLabTest"] = this.prescriptionLabTest ? this.prescriptionLabTest.toJSON() : <any>undefined;
        return data;
    }

    clone(): LabReportResultItem {
        const json = this.toJSON();
        let result = new LabReportResultItem();
        result.init(json);
        return result;
    }
}

export interface ILabReportResultItem {
    id: number;
    test: string | undefined;
    result: number;
    minValue: number;
    maxValue: number;
    unit: string | undefined;
    flag: string | undefined;
    prescriptionLabTestId: number;
    prescriptionLabTest: PrescriptionLabTest;
}

export class LabReportResultItemDto implements ILabReportResultItemDto {
    id: number;
    test: string | undefined;
    result: string | undefined;
    minValue: number;
    maxValue: number;
    unit: string | undefined;
    flag: string | undefined;
    prescriptionLabTest: PrescriptionLabTestDto;

    constructor(data?: ILabReportResultItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.test = _data["test"];
            this.result = _data["result"];
            this.minValue = _data["minValue"];
            this.maxValue = _data["maxValue"];
            this.unit = _data["unit"];
            this.flag = _data["flag"];
            this.prescriptionLabTest = _data["prescriptionLabTest"] ? PrescriptionLabTestDto.fromJS(_data["prescriptionLabTest"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LabReportResultItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LabReportResultItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["test"] = this.test;
        data["result"] = this.result;
        data["minValue"] = this.minValue;
        data["maxValue"] = this.maxValue;
        data["unit"] = this.unit;
        data["flag"] = this.flag;
        data["prescriptionLabTest"] = this.prescriptionLabTest ? this.prescriptionLabTest.toJSON() : <any>undefined;
        return data;
    }

    clone(): LabReportResultItemDto {
        const json = this.toJSON();
        let result = new LabReportResultItemDto();
        result.init(json);
        return result;
    }
}

export interface ILabReportResultItemDto {
    id: number;
    test: string | undefined;
    result: string | undefined;
    minValue: number;
    maxValue: number;
    unit: string | undefined;
    flag: string | undefined;
    prescriptionLabTest: PrescriptionLabTestDto;
}

export class LabReportResultItemDtoPagedResultDto implements ILabReportResultItemDtoPagedResultDto {
    items: LabReportResultItemDto[] | undefined;
    totalCount: number;

    constructor(data?: ILabReportResultItemDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LabReportResultItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LabReportResultItemDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LabReportResultItemDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): LabReportResultItemDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LabReportResultItemDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILabReportResultItemDtoPagedResultDto {
    items: LabReportResultItemDto[] | undefined;
    totalCount: number;
}

export class LabReportsType implements ILabReportsType {
    id: number;
    tenantId: number;
    reportType: string | undefined;
    reportPrice: number;
    prescriptionLabTests: PrescriptionLabTest[] | undefined;

    constructor(data?: ILabReportsType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.reportType = _data["reportType"];
            this.reportPrice = _data["reportPrice"];
            if (Array.isArray(_data["prescriptionLabTests"])) {
                this.prescriptionLabTests = [] as any;
                for (let item of _data["prescriptionLabTests"])
                    this.prescriptionLabTests.push(PrescriptionLabTest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LabReportsType {
        data = typeof data === 'object' ? data : {};
        let result = new LabReportsType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["reportType"] = this.reportType;
        data["reportPrice"] = this.reportPrice;
        if (Array.isArray(this.prescriptionLabTests)) {
            data["prescriptionLabTests"] = [];
            for (let item of this.prescriptionLabTests)
                data["prescriptionLabTests"].push(item.toJSON());
        }
        return data;
    }

    clone(): LabReportsType {
        const json = this.toJSON();
        let result = new LabReportsType();
        result.init(json);
        return result;
    }
}

export interface ILabReportsType {
    id: number;
    tenantId: number;
    reportType: string | undefined;
    reportPrice: number;
    prescriptionLabTests: PrescriptionLabTest[] | undefined;
}

export class LabReportsTypeDto implements ILabReportsTypeDto {
    id: number;
    tenantId: number;
    reportType: string | undefined;
    reportPrice: number;

    constructor(data?: ILabReportsTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.reportType = _data["reportType"];
            this.reportPrice = _data["reportPrice"];
        }
    }

    static fromJS(data: any): LabReportsTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new LabReportsTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["reportType"] = this.reportType;
        data["reportPrice"] = this.reportPrice;
        return data;
    }

    clone(): LabReportsTypeDto {
        const json = this.toJSON();
        let result = new LabReportsTypeDto();
        result.init(json);
        return result;
    }
}

export interface ILabReportsTypeDto {
    id: number;
    tenantId: number;
    reportType: string | undefined;
    reportPrice: number;
}

export class LabReportsTypeDtoListResultDto implements ILabReportsTypeDtoListResultDto {
    items: LabReportsTypeDto[] | undefined;

    constructor(data?: ILabReportsTypeDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LabReportsTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LabReportsTypeDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LabReportsTypeDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): LabReportsTypeDtoListResultDto {
        const json = this.toJSON();
        let result = new LabReportsTypeDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface ILabReportsTypeDtoListResultDto {
    items: LabReportsTypeDto[] | undefined;
}

export class LabReportsTypeDtoPagedResultDto implements ILabReportsTypeDtoPagedResultDto {
    items: LabReportsTypeDto[] | undefined;
    totalCount: number;

    constructor(data?: ILabReportsTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LabReportsTypeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LabReportsTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LabReportsTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): LabReportsTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LabReportsTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILabReportsTypeDtoPagedResultDto {
    items: LabReportsTypeDto[] | undefined;
    totalCount: number;
}

export class LabRequestListDto implements ILabRequestListDto {
    id: number;
    patientId: number;
    patientName: string | undefined;
    doctorId: number;
    doctorName: string | undefined;
    prescriptionId: number;
    labReportsTypeId: number;
    labReportTypeName: string | undefined;
    testStatus: LabTestStatus;

    constructor(data?: ILabRequestListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.patientId = _data["patientId"];
            this.patientName = _data["patientName"];
            this.doctorId = _data["doctorId"];
            this.doctorName = _data["doctorName"];
            this.prescriptionId = _data["prescriptionId"];
            this.labReportsTypeId = _data["labReportsTypeId"];
            this.labReportTypeName = _data["labReportTypeName"];
            this.testStatus = _data["testStatus"];
        }
    }

    static fromJS(data: any): LabRequestListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LabRequestListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["patientId"] = this.patientId;
        data["patientName"] = this.patientName;
        data["doctorId"] = this.doctorId;
        data["doctorName"] = this.doctorName;
        data["prescriptionId"] = this.prescriptionId;
        data["labReportsTypeId"] = this.labReportsTypeId;
        data["labReportTypeName"] = this.labReportTypeName;
        data["testStatus"] = this.testStatus;
        return data;
    }

    clone(): LabRequestListDto {
        const json = this.toJSON();
        let result = new LabRequestListDto();
        result.init(json);
        return result;
    }
}

export interface ILabRequestListDto {
    id: number;
    patientId: number;
    patientName: string | undefined;
    doctorId: number;
    doctorName: string | undefined;
    prescriptionId: number;
    labReportsTypeId: number;
    labReportTypeName: string | undefined;
    testStatus: LabTestStatus;
}

export class LabRequestListDtoPagedResultDto implements ILabRequestListDtoPagedResultDto {
    items: LabRequestListDto[] | undefined;
    totalCount: number;

    constructor(data?: ILabRequestListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LabRequestListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LabRequestListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LabRequestListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): LabRequestListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LabRequestListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILabRequestListDtoPagedResultDto {
    items: LabRequestListDto[] | undefined;
    totalCount: number;
}

export class LabTechnician implements ILabTechnician {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    department: LabDepartment;
    certificationNumber: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    abpUserId: number;
    abpUser: User;

    constructor(data?: ILabTechnician) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.qualification = _data["qualification"];
            this.yearsOfExperience = _data["yearsOfExperience"];
            this.department = _data["department"];
            this.certificationNumber = _data["certificationNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.abpUserId = _data["abpUserId"];
            this.abpUser = _data["abpUser"] ? User.fromJS(_data["abpUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LabTechnician {
        data = typeof data === 'object' ? data : {};
        let result = new LabTechnician();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["qualification"] = this.qualification;
        data["yearsOfExperience"] = this.yearsOfExperience;
        data["department"] = this.department;
        data["certificationNumber"] = this.certificationNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["abpUserId"] = this.abpUserId;
        data["abpUser"] = this.abpUser ? this.abpUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): LabTechnician {
        const json = this.toJSON();
        let result = new LabTechnician();
        result.init(json);
        return result;
    }
}

export interface ILabTechnician {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    department: LabDepartment;
    certificationNumber: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    abpUserId: number;
    abpUser: User;
}

export class LabTechniciansDto implements ILabTechniciansDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    department: LabDepartment;
    certificationNumber: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    abpUser: UserDto;

    constructor(data?: ILabTechniciansDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.qualification = _data["qualification"];
            this.yearsOfExperience = _data["yearsOfExperience"];
            this.department = _data["department"];
            this.certificationNumber = _data["certificationNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.abpUser = _data["abpUser"] ? UserDto.fromJS(_data["abpUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LabTechniciansDto {
        data = typeof data === 'object' ? data : {};
        let result = new LabTechniciansDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["qualification"] = this.qualification;
        data["yearsOfExperience"] = this.yearsOfExperience;
        data["department"] = this.department;
        data["certificationNumber"] = this.certificationNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["abpUser"] = this.abpUser ? this.abpUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): LabTechniciansDto {
        const json = this.toJSON();
        let result = new LabTechniciansDto();
        result.init(json);
        return result;
    }
}

export interface ILabTechniciansDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    department: LabDepartment;
    certificationNumber: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    abpUser: UserDto;
}

export class LabTechniciansDtoPagedResultDto implements ILabTechniciansDtoPagedResultDto {
    items: LabTechniciansDto[] | undefined;
    totalCount: number;

    constructor(data?: ILabTechniciansDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LabTechniciansDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LabTechniciansDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LabTechniciansDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): LabTechniciansDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LabTechniciansDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILabTechniciansDtoPagedResultDto {
    items: LabTechniciansDto[] | undefined;
    totalCount: number;
}

export class LabTestDetailDto implements ILabTestDetailDto {
    prescriptionLabTestId: number;
    testName: string | undefined;
    price: number;

    constructor(data?: ILabTestDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.prescriptionLabTestId = _data["prescriptionLabTestId"];
            this.testName = _data["testName"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): LabTestDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new LabTestDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prescriptionLabTestId"] = this.prescriptionLabTestId;
        data["testName"] = this.testName;
        data["price"] = this.price;
        return data;
    }

    clone(): LabTestDetailDto {
        const json = this.toJSON();
        let result = new LabTestDetailDto();
        result.init(json);
        return result;
    }
}

export interface ILabTestDetailDto {
    prescriptionLabTestId: number;
    testName: string | undefined;
    price: number;
}

export enum LabTestStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class MedicineDetailDto implements IMedicineDetailDto {
    prescriptionItemId: number;
    medicineName: string | undefined;
    price: number;
    quantity: number;

    constructor(data?: IMedicineDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.prescriptionItemId = _data["prescriptionItemId"];
            this.medicineName = _data["medicineName"];
            this.price = _data["price"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): MedicineDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MedicineDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prescriptionItemId"] = this.prescriptionItemId;
        data["medicineName"] = this.medicineName;
        data["price"] = this.price;
        data["quantity"] = this.quantity;
        return data;
    }

    clone(): MedicineDetailDto {
        const json = this.toJSON();
        let result = new MedicineDetailDto();
        result.init(json);
        return result;
    }
}

export interface IMedicineDetailDto {
    prescriptionItemId: number;
    medicineName: string | undefined;
    price: number;
    quantity: number;
}

export class MedicineOrder implements IMedicineOrder {
    id: number;
    tenantId: number;
    nurseId: number;
    nurse: Nurse;
    patientId: number | undefined;
    patient: Patient;
    orderDate: moment.Moment;
    status: OrderStatus;
    priority: OrderPriority;
    items: MedicineOrderItem[] | undefined;

    constructor(data?: IMedicineOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.nurseId = _data["nurseId"];
            this.nurse = _data["nurse"] ? Nurse.fromJS(_data["nurse"]) : <any>undefined;
            this.patientId = _data["patientId"];
            this.patient = _data["patient"] ? Patient.fromJS(_data["patient"]) : <any>undefined;
            this.orderDate = _data["orderDate"] ? moment(_data["orderDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.priority = _data["priority"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MedicineOrderItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MedicineOrder {
        data = typeof data === 'object' ? data : {};
        let result = new MedicineOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["nurseId"] = this.nurseId;
        data["nurse"] = this.nurse ? this.nurse.toJSON() : <any>undefined;
        data["patientId"] = this.patientId;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>undefined;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["priority"] = this.priority;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): MedicineOrder {
        const json = this.toJSON();
        let result = new MedicineOrder();
        result.init(json);
        return result;
    }
}

export interface IMedicineOrder {
    id: number;
    tenantId: number;
    nurseId: number;
    nurse: Nurse;
    patientId: number | undefined;
    patient: Patient;
    orderDate: moment.Moment;
    status: OrderStatus;
    priority: OrderPriority;
    items: MedicineOrderItem[] | undefined;
}

export class MedicineOrderDto implements IMedicineOrderDto {
    id: number;
    tenantId: number;
    nurseId: number;
    nurse: NurseDto;
    patientId: number | undefined;
    patient: PatientDto;
    orderDate: moment.Moment;
    status: string | undefined;
    priority: string | undefined;
    items: MedicineOrderItemDto[] | undefined;

    constructor(data?: IMedicineOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.nurseId = _data["nurseId"];
            this.nurse = _data["nurse"] ? NurseDto.fromJS(_data["nurse"]) : <any>undefined;
            this.patientId = _data["patientId"];
            this.patient = _data["patient"] ? PatientDto.fromJS(_data["patient"]) : <any>undefined;
            this.orderDate = _data["orderDate"] ? moment(_data["orderDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.priority = _data["priority"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MedicineOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MedicineOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new MedicineOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["nurseId"] = this.nurseId;
        data["nurse"] = this.nurse ? this.nurse.toJSON() : <any>undefined;
        data["patientId"] = this.patientId;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>undefined;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["priority"] = this.priority;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): MedicineOrderDto {
        const json = this.toJSON();
        let result = new MedicineOrderDto();
        result.init(json);
        return result;
    }
}

export interface IMedicineOrderDto {
    id: number;
    tenantId: number;
    nurseId: number;
    nurse: NurseDto;
    patientId: number | undefined;
    patient: PatientDto;
    orderDate: moment.Moment;
    status: string | undefined;
    priority: string | undefined;
    items: MedicineOrderItemDto[] | undefined;
}

export class MedicineOrderDtoPagedResultDto implements IMedicineOrderDtoPagedResultDto {
    items: MedicineOrderDto[] | undefined;
    totalCount: number;

    constructor(data?: IMedicineOrderDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MedicineOrderDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MedicineOrderDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MedicineOrderDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): MedicineOrderDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MedicineOrderDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMedicineOrderDtoPagedResultDto {
    items: MedicineOrderDto[] | undefined;
    totalCount: number;
}

export class MedicineOrderItem implements IMedicineOrderItem {
    id: number;
    medicineOrderId: number;
    medicineOrder: MedicineOrder;
    medicineName: string | undefined;
    medicineId: number;
    medicine: PharmacistInventory;
    quantity: number;
    dosage: string | undefined;

    constructor(data?: IMedicineOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.medicineOrderId = _data["medicineOrderId"];
            this.medicineOrder = _data["medicineOrder"] ? MedicineOrder.fromJS(_data["medicineOrder"]) : <any>undefined;
            this.medicineName = _data["medicineName"];
            this.medicineId = _data["medicineId"];
            this.medicine = _data["medicine"] ? PharmacistInventory.fromJS(_data["medicine"]) : <any>undefined;
            this.quantity = _data["quantity"];
            this.dosage = _data["dosage"];
        }
    }

    static fromJS(data: any): MedicineOrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new MedicineOrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["medicineOrderId"] = this.medicineOrderId;
        data["medicineOrder"] = this.medicineOrder ? this.medicineOrder.toJSON() : <any>undefined;
        data["medicineName"] = this.medicineName;
        data["medicineId"] = this.medicineId;
        data["medicine"] = this.medicine ? this.medicine.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        data["dosage"] = this.dosage;
        return data;
    }

    clone(): MedicineOrderItem {
        const json = this.toJSON();
        let result = new MedicineOrderItem();
        result.init(json);
        return result;
    }
}

export interface IMedicineOrderItem {
    id: number;
    medicineOrderId: number;
    medicineOrder: MedicineOrder;
    medicineName: string | undefined;
    medicineId: number;
    medicine: PharmacistInventory;
    quantity: number;
    dosage: string | undefined;
}

export class MedicineOrderItemDto implements IMedicineOrderItemDto {
    id: number;
    medicineOrderId: number;
    medicineId: number;
    medicineName: string | undefined;
    quantity: number;
    dosage: string | undefined;

    constructor(data?: IMedicineOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.medicineOrderId = _data["medicineOrderId"];
            this.medicineId = _data["medicineId"];
            this.medicineName = _data["medicineName"];
            this.quantity = _data["quantity"];
            this.dosage = _data["dosage"];
        }
    }

    static fromJS(data: any): MedicineOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new MedicineOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["medicineOrderId"] = this.medicineOrderId;
        data["medicineId"] = this.medicineId;
        data["medicineName"] = this.medicineName;
        data["quantity"] = this.quantity;
        data["dosage"] = this.dosage;
        return data;
    }

    clone(): MedicineOrderItemDto {
        const json = this.toJSON();
        let result = new MedicineOrderItemDto();
        result.init(json);
        return result;
    }
}

export interface IMedicineOrderItemDto {
    id: number;
    medicineOrderId: number;
    medicineId: number;
    medicineName: string | undefined;
    quantity: number;
    dosage: string | undefined;
}

export class Nurse implements INurse {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    shiftTiming: string | undefined;
    department: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    dateOfBirth: moment.Moment | undefined;
    abpUserId: number;
    abpUser: User;
    vitals: Vital[] | undefined;
    visits: Visit[] | undefined;
    medicineOrders: MedicineOrder[] | undefined;
    admissions: Admission[] | undefined;

    constructor(data?: INurse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.shiftTiming = _data["shiftTiming"];
            this.department = _data["department"];
            this.qualification = _data["qualification"];
            this.yearsOfExperience = _data["yearsOfExperience"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.abpUserId = _data["abpUserId"];
            this.abpUser = _data["abpUser"] ? User.fromJS(_data["abpUser"]) : <any>undefined;
            if (Array.isArray(_data["vitals"])) {
                this.vitals = [] as any;
                for (let item of _data["vitals"])
                    this.vitals.push(Vital.fromJS(item));
            }
            if (Array.isArray(_data["visits"])) {
                this.visits = [] as any;
                for (let item of _data["visits"])
                    this.visits.push(Visit.fromJS(item));
            }
            if (Array.isArray(_data["medicineOrders"])) {
                this.medicineOrders = [] as any;
                for (let item of _data["medicineOrders"])
                    this.medicineOrders.push(MedicineOrder.fromJS(item));
            }
            if (Array.isArray(_data["admissions"])) {
                this.admissions = [] as any;
                for (let item of _data["admissions"])
                    this.admissions.push(Admission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Nurse {
        data = typeof data === 'object' ? data : {};
        let result = new Nurse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["shiftTiming"] = this.shiftTiming;
        data["department"] = this.department;
        data["qualification"] = this.qualification;
        data["yearsOfExperience"] = this.yearsOfExperience;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["abpUserId"] = this.abpUserId;
        data["abpUser"] = this.abpUser ? this.abpUser.toJSON() : <any>undefined;
        if (Array.isArray(this.vitals)) {
            data["vitals"] = [];
            for (let item of this.vitals)
                data["vitals"].push(item.toJSON());
        }
        if (Array.isArray(this.visits)) {
            data["visits"] = [];
            for (let item of this.visits)
                data["visits"].push(item.toJSON());
        }
        if (Array.isArray(this.medicineOrders)) {
            data["medicineOrders"] = [];
            for (let item of this.medicineOrders)
                data["medicineOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.admissions)) {
            data["admissions"] = [];
            for (let item of this.admissions)
                data["admissions"].push(item.toJSON());
        }
        return data;
    }

    clone(): Nurse {
        const json = this.toJSON();
        let result = new Nurse();
        result.init(json);
        return result;
    }
}

export interface INurse {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    shiftTiming: string | undefined;
    department: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    dateOfBirth: moment.Moment | undefined;
    abpUserId: number;
    abpUser: User;
    vitals: Vital[] | undefined;
    visits: Visit[] | undefined;
    medicineOrders: MedicineOrder[] | undefined;
    admissions: Admission[] | undefined;
}

export class NurseDto implements INurseDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    gender: string | undefined;
    shiftTiming: string | undefined;
    department: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    dateOfBirth: moment.Moment | undefined;
    abpUser: UserDto;

    constructor(data?: INurseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.shiftTiming = _data["shiftTiming"];
            this.department = _data["department"];
            this.qualification = _data["qualification"];
            this.yearsOfExperience = _data["yearsOfExperience"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.abpUser = _data["abpUser"] ? UserDto.fromJS(_data["abpUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NurseDto {
        data = typeof data === 'object' ? data : {};
        let result = new NurseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["shiftTiming"] = this.shiftTiming;
        data["department"] = this.department;
        data["qualification"] = this.qualification;
        data["yearsOfExperience"] = this.yearsOfExperience;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["abpUser"] = this.abpUser ? this.abpUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): NurseDto {
        const json = this.toJSON();
        let result = new NurseDto();
        result.init(json);
        return result;
    }
}

export interface INurseDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    gender: string | undefined;
    shiftTiming: string | undefined;
    department: string | undefined;
    qualification: string | undefined;
    yearsOfExperience: number;
    dateOfBirth: moment.Moment | undefined;
    abpUser: UserDto;
}

export class NurseDtoListResultDto implements INurseDtoListResultDto {
    items: NurseDto[] | undefined;

    constructor(data?: INurseDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(NurseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NurseDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NurseDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): NurseDtoListResultDto {
        const json = this.toJSON();
        let result = new NurseDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface INurseDtoListResultDto {
    items: NurseDto[] | undefined;
}

export class NurseDtoPagedResultDto implements INurseDtoPagedResultDto {
    items: NurseDto[] | undefined;
    totalCount: number;

    constructor(data?: INurseDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(NurseDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): NurseDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NurseDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): NurseDtoPagedResultDto {
        const json = this.toJSON();
        let result = new NurseDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INurseDtoPagedResultDto {
    items: NurseDto[] | undefined;
    totalCount: number;
}

export enum OrderPriority {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum OrderStatus {
    _0 = 0,
    _1 = 1,
}

export class Patient implements IPatient {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    dateOfBirth: moment.Moment;
    gender: string | undefined;
    address: string | undefined;
    bloodGroup: string | undefined;
    emergencyContactName: string | undefined;
    emergencyContactNumber: string | undefined;
    isAdmitted: boolean;
    abpUserId: number;
    abpUser: User;
    prescriptions: Prescription[] | undefined;
    admissions: Admission[] | undefined;
    deposits: Deposit[] | undefined;
    vitals: Vital[] | undefined;
    appointments: Appointment[] | undefined;
    visit: Visit[] | undefined;
    medicineOrders: MedicineOrder[] | undefined;

    constructor(data?: IPatient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.address = _data["address"];
            this.bloodGroup = _data["bloodGroup"];
            this.emergencyContactName = _data["emergencyContactName"];
            this.emergencyContactNumber = _data["emergencyContactNumber"];
            this.isAdmitted = _data["isAdmitted"];
            this.abpUserId = _data["abpUserId"];
            this.abpUser = _data["abpUser"] ? User.fromJS(_data["abpUser"]) : <any>undefined;
            if (Array.isArray(_data["prescriptions"])) {
                this.prescriptions = [] as any;
                for (let item of _data["prescriptions"])
                    this.prescriptions.push(Prescription.fromJS(item));
            }
            if (Array.isArray(_data["admissions"])) {
                this.admissions = [] as any;
                for (let item of _data["admissions"])
                    this.admissions.push(Admission.fromJS(item));
            }
            if (Array.isArray(_data["deposits"])) {
                this.deposits = [] as any;
                for (let item of _data["deposits"])
                    this.deposits.push(Deposit.fromJS(item));
            }
            if (Array.isArray(_data["vitals"])) {
                this.vitals = [] as any;
                for (let item of _data["vitals"])
                    this.vitals.push(Vital.fromJS(item));
            }
            if (Array.isArray(_data["appointments"])) {
                this.appointments = [] as any;
                for (let item of _data["appointments"])
                    this.appointments.push(Appointment.fromJS(item));
            }
            if (Array.isArray(_data["visit"])) {
                this.visit = [] as any;
                for (let item of _data["visit"])
                    this.visit.push(Visit.fromJS(item));
            }
            if (Array.isArray(_data["medicineOrders"])) {
                this.medicineOrders = [] as any;
                for (let item of _data["medicineOrders"])
                    this.medicineOrders.push(MedicineOrder.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Patient {
        data = typeof data === 'object' ? data : {};
        let result = new Patient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["address"] = this.address;
        data["bloodGroup"] = this.bloodGroup;
        data["emergencyContactName"] = this.emergencyContactName;
        data["emergencyContactNumber"] = this.emergencyContactNumber;
        data["isAdmitted"] = this.isAdmitted;
        data["abpUserId"] = this.abpUserId;
        data["abpUser"] = this.abpUser ? this.abpUser.toJSON() : <any>undefined;
        if (Array.isArray(this.prescriptions)) {
            data["prescriptions"] = [];
            for (let item of this.prescriptions)
                data["prescriptions"].push(item.toJSON());
        }
        if (Array.isArray(this.admissions)) {
            data["admissions"] = [];
            for (let item of this.admissions)
                data["admissions"].push(item.toJSON());
        }
        if (Array.isArray(this.deposits)) {
            data["deposits"] = [];
            for (let item of this.deposits)
                data["deposits"].push(item.toJSON());
        }
        if (Array.isArray(this.vitals)) {
            data["vitals"] = [];
            for (let item of this.vitals)
                data["vitals"].push(item.toJSON());
        }
        if (Array.isArray(this.appointments)) {
            data["appointments"] = [];
            for (let item of this.appointments)
                data["appointments"].push(item.toJSON());
        }
        if (Array.isArray(this.visit)) {
            data["visit"] = [];
            for (let item of this.visit)
                data["visit"].push(item.toJSON());
        }
        if (Array.isArray(this.medicineOrders)) {
            data["medicineOrders"] = [];
            for (let item of this.medicineOrders)
                data["medicineOrders"].push(item.toJSON());
        }
        return data;
    }

    clone(): Patient {
        const json = this.toJSON();
        let result = new Patient();
        result.init(json);
        return result;
    }
}

export interface IPatient {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    dateOfBirth: moment.Moment;
    gender: string | undefined;
    address: string | undefined;
    bloodGroup: string | undefined;
    emergencyContactName: string | undefined;
    emergencyContactNumber: string | undefined;
    isAdmitted: boolean;
    abpUserId: number;
    abpUser: User;
    prescriptions: Prescription[] | undefined;
    admissions: Admission[] | undefined;
    deposits: Deposit[] | undefined;
    vitals: Vital[] | undefined;
    appointments: Appointment[] | undefined;
    visit: Visit[] | undefined;
    medicineOrders: MedicineOrder[] | undefined;
}

export class PatientAppointmentHistoryDto implements IPatientAppointmentHistoryDto {
    appointmentDate: moment.Moment;
    startTime: string;
    isFollowUp: boolean;
    doctorId: number;
    doctorName: string | undefined;
    nurseId: number | undefined;
    nurseName: string | undefined;
    status: AppointmentStatus;
    reasonForVisit: string | undefined;

    constructor(data?: IPatientAppointmentHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appointmentDate = _data["appointmentDate"] ? moment(_data["appointmentDate"].toString()) : <any>undefined;
            this.startTime = _data["startTime"];
            this.isFollowUp = _data["isFollowUp"];
            this.doctorId = _data["doctorId"];
            this.doctorName = _data["doctorName"];
            this.nurseId = _data["nurseId"];
            this.nurseName = _data["nurseName"];
            this.status = _data["status"];
            this.reasonForVisit = _data["reasonForVisit"];
        }
    }

    static fromJS(data: any): PatientAppointmentHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientAppointmentHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>undefined;
        data["startTime"] = this.startTime;
        data["isFollowUp"] = this.isFollowUp;
        data["doctorId"] = this.doctorId;
        data["doctorName"] = this.doctorName;
        data["nurseId"] = this.nurseId;
        data["nurseName"] = this.nurseName;
        data["status"] = this.status;
        data["reasonForVisit"] = this.reasonForVisit;
        return data;
    }

    clone(): PatientAppointmentHistoryDto {
        const json = this.toJSON();
        let result = new PatientAppointmentHistoryDto();
        result.init(json);
        return result;
    }
}

export interface IPatientAppointmentHistoryDto {
    appointmentDate: moment.Moment;
    startTime: string;
    isFollowUp: boolean;
    doctorId: number;
    doctorName: string | undefined;
    nurseId: number | undefined;
    nurseName: string | undefined;
    status: AppointmentStatus;
    reasonForVisit: string | undefined;
}

export class PatientDetailsAndMedicalHistoryDto implements IPatientDetailsAndMedicalHistoryDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    dateOfBirth: moment.Moment;
    gender: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    address: string | undefined;
    bloodGroup: string | undefined;
    emergencyContactName: string | undefined;
    emergencyContactNumber: string | undefined;
    billingMethod: BillingMethod;
    paymentMethod: PaymentMethod;
    admissionDate: moment.Moment | undefined;
    abpUserId: number;
    assignedNurseId: number | undefined;
    assignedDoctorId: number | undefined;
    assignedNurseName: string | undefined;
    assignedDoctorName: string | undefined;
    patientVitalsDetails: PatientVitalsDetailsDto;
    patientAppointmentHistory: PatientAppointmentHistoryDto[] | undefined;
    patientPrescriptionsHistory: PatientPrescriptionsHistoryDto[] | undefined;

    constructor(data?: IPatientDetailsAndMedicalHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.bloodGroup = _data["bloodGroup"];
            this.emergencyContactName = _data["emergencyContactName"];
            this.emergencyContactNumber = _data["emergencyContactNumber"];
            this.billingMethod = _data["billingMethod"];
            this.paymentMethod = _data["paymentMethod"];
            this.admissionDate = _data["admissionDate"] ? moment(_data["admissionDate"].toString()) : <any>undefined;
            this.abpUserId = _data["abpUserId"];
            this.assignedNurseId = _data["assignedNurseId"];
            this.assignedDoctorId = _data["assignedDoctorId"];
            this.assignedNurseName = _data["assignedNurseName"];
            this.assignedDoctorName = _data["assignedDoctorName"];
            this.patientVitalsDetails = _data["patientVitalsDetails"] ? PatientVitalsDetailsDto.fromJS(_data["patientVitalsDetails"]) : <any>undefined;
            if (Array.isArray(_data["patientAppointmentHistory"])) {
                this.patientAppointmentHistory = [] as any;
                for (let item of _data["patientAppointmentHistory"])
                    this.patientAppointmentHistory.push(PatientAppointmentHistoryDto.fromJS(item));
            }
            if (Array.isArray(_data["patientPrescriptionsHistory"])) {
                this.patientPrescriptionsHistory = [] as any;
                for (let item of _data["patientPrescriptionsHistory"])
                    this.patientPrescriptionsHistory.push(PatientPrescriptionsHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PatientDetailsAndMedicalHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientDetailsAndMedicalHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["bloodGroup"] = this.bloodGroup;
        data["emergencyContactName"] = this.emergencyContactName;
        data["emergencyContactNumber"] = this.emergencyContactNumber;
        data["billingMethod"] = this.billingMethod;
        data["paymentMethod"] = this.paymentMethod;
        data["admissionDate"] = this.admissionDate ? this.admissionDate.toISOString() : <any>undefined;
        data["abpUserId"] = this.abpUserId;
        data["assignedNurseId"] = this.assignedNurseId;
        data["assignedDoctorId"] = this.assignedDoctorId;
        data["assignedNurseName"] = this.assignedNurseName;
        data["assignedDoctorName"] = this.assignedDoctorName;
        data["patientVitalsDetails"] = this.patientVitalsDetails ? this.patientVitalsDetails.toJSON() : <any>undefined;
        if (Array.isArray(this.patientAppointmentHistory)) {
            data["patientAppointmentHistory"] = [];
            for (let item of this.patientAppointmentHistory)
                data["patientAppointmentHistory"].push(item.toJSON());
        }
        if (Array.isArray(this.patientPrescriptionsHistory)) {
            data["patientPrescriptionsHistory"] = [];
            for (let item of this.patientPrescriptionsHistory)
                data["patientPrescriptionsHistory"].push(item.toJSON());
        }
        return data;
    }

    clone(): PatientDetailsAndMedicalHistoryDto {
        const json = this.toJSON();
        let result = new PatientDetailsAndMedicalHistoryDto();
        result.init(json);
        return result;
    }
}

export interface IPatientDetailsAndMedicalHistoryDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    dateOfBirth: moment.Moment;
    gender: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    address: string | undefined;
    bloodGroup: string | undefined;
    emergencyContactName: string | undefined;
    emergencyContactNumber: string | undefined;
    billingMethod: BillingMethod;
    paymentMethod: PaymentMethod;
    admissionDate: moment.Moment | undefined;
    abpUserId: number;
    assignedNurseId: number | undefined;
    assignedDoctorId: number | undefined;
    assignedNurseName: string | undefined;
    assignedDoctorName: string | undefined;
    patientVitalsDetails: PatientVitalsDetailsDto;
    patientAppointmentHistory: PatientAppointmentHistoryDto[] | undefined;
    patientPrescriptionsHistory: PatientPrescriptionsHistoryDto[] | undefined;
}

export class PatientDropDownDto implements IPatientDropDownDto {
    id: number;
    fullName: string | undefined;
    isAdmitted: boolean;

    constructor(data?: IPatientDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.isAdmitted = _data["isAdmitted"];
        }
    }

    static fromJS(data: any): PatientDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["isAdmitted"] = this.isAdmitted;
        return data;
    }

    clone(): PatientDropDownDto {
        const json = this.toJSON();
        let result = new PatientDropDownDto();
        result.init(json);
        return result;
    }
}

export interface IPatientDropDownDto {
    id: number;
    fullName: string | undefined;
    isAdmitted: boolean;
}

export class PatientDto implements IPatientDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    dateOfBirth: moment.Moment;
    gender: string | undefined;
    address: string | undefined;
    bloodGroup: string | undefined;
    emergencyContactName: string | undefined;
    emergencyContactNumber: string | undefined;
    abpUser: UserDto;
    doctors: DoctorDto;
    nurses: NurseDto;
    prescriptions: PrescriptionDto[] | undefined;

    constructor(data?: IPatientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.address = _data["address"];
            this.bloodGroup = _data["bloodGroup"];
            this.emergencyContactName = _data["emergencyContactName"];
            this.emergencyContactNumber = _data["emergencyContactNumber"];
            this.abpUser = _data["abpUser"] ? UserDto.fromJS(_data["abpUser"]) : <any>undefined;
            this.doctors = _data["doctors"] ? DoctorDto.fromJS(_data["doctors"]) : <any>undefined;
            this.nurses = _data["nurses"] ? NurseDto.fromJS(_data["nurses"]) : <any>undefined;
            if (Array.isArray(_data["prescriptions"])) {
                this.prescriptions = [] as any;
                for (let item of _data["prescriptions"])
                    this.prescriptions.push(PrescriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PatientDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["address"] = this.address;
        data["bloodGroup"] = this.bloodGroup;
        data["emergencyContactName"] = this.emergencyContactName;
        data["emergencyContactNumber"] = this.emergencyContactNumber;
        data["abpUser"] = this.abpUser ? this.abpUser.toJSON() : <any>undefined;
        data["doctors"] = this.doctors ? this.doctors.toJSON() : <any>undefined;
        data["nurses"] = this.nurses ? this.nurses.toJSON() : <any>undefined;
        if (Array.isArray(this.prescriptions)) {
            data["prescriptions"] = [];
            for (let item of this.prescriptions)
                data["prescriptions"].push(item.toJSON());
        }
        return data;
    }

    clone(): PatientDto {
        const json = this.toJSON();
        let result = new PatientDto();
        result.init(json);
        return result;
    }
}

export interface IPatientDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    dateOfBirth: moment.Moment;
    gender: string | undefined;
    address: string | undefined;
    bloodGroup: string | undefined;
    emergencyContactName: string | undefined;
    emergencyContactNumber: string | undefined;
    abpUser: UserDto;
    doctors: DoctorDto;
    nurses: NurseDto;
    prescriptions: PrescriptionDto[] | undefined;
}

export class PatientDtoPagedResultDto implements IPatientDtoPagedResultDto {
    items: PatientDto[] | undefined;
    totalCount: number;

    constructor(data?: IPatientDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PatientDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PatientDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PatientDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PatientDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPatientDtoPagedResultDto {
    items: PatientDto[] | undefined;
    totalCount: number;
}

export class PatientPrescriptionsHistoryDto implements IPatientPrescriptionsHistoryDto {
    doctorId: number;
    doctorName: string | undefined;
    items: PatientPrescriptionsItemHistoryDto[] | undefined;

    constructor(data?: IPatientPrescriptionsHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.doctorId = _data["doctorId"];
            this.doctorName = _data["doctorName"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PatientPrescriptionsItemHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PatientPrescriptionsHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientPrescriptionsHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["doctorId"] = this.doctorId;
        data["doctorName"] = this.doctorName;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PatientPrescriptionsHistoryDto {
        const json = this.toJSON();
        let result = new PatientPrescriptionsHistoryDto();
        result.init(json);
        return result;
    }
}

export interface IPatientPrescriptionsHistoryDto {
    doctorId: number;
    doctorName: string | undefined;
    items: PatientPrescriptionsItemHistoryDto[] | undefined;
}

export class PatientPrescriptionsItemHistoryDto implements IPatientPrescriptionsItemHistoryDto {
    medicineName: string | undefined;
    dosage: string | undefined;
    frequency: string | undefined;
    duration: string | undefined;
    prescriptionId: number;

    constructor(data?: IPatientPrescriptionsItemHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.medicineName = _data["medicineName"];
            this.dosage = _data["dosage"];
            this.frequency = _data["frequency"];
            this.duration = _data["duration"];
            this.prescriptionId = _data["prescriptionId"];
        }
    }

    static fromJS(data: any): PatientPrescriptionsItemHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientPrescriptionsItemHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["medicineName"] = this.medicineName;
        data["dosage"] = this.dosage;
        data["frequency"] = this.frequency;
        data["duration"] = this.duration;
        data["prescriptionId"] = this.prescriptionId;
        return data;
    }

    clone(): PatientPrescriptionsItemHistoryDto {
        const json = this.toJSON();
        let result = new PatientPrescriptionsItemHistoryDto();
        result.init(json);
        return result;
    }
}

export interface IPatientPrescriptionsItemHistoryDto {
    medicineName: string | undefined;
    dosage: string | undefined;
    frequency: string | undefined;
    duration: string | undefined;
    prescriptionId: number;
}

export class PatientVitalsDetailsDto implements IPatientVitalsDetailsDto {
    bloodPressure: string | undefined;
    heartRate: string | undefined;
    respirationRate: number;
    temperature: number;
    oxygenSaturation: number;
    height: string | undefined;
    weight: string | undefined;
    bmi: string | undefined;
    dateRecorded: moment.Moment | undefined;

    constructor(data?: IPatientVitalsDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bloodPressure = _data["bloodPressure"];
            this.heartRate = _data["heartRate"];
            this.respirationRate = _data["respirationRate"];
            this.temperature = _data["temperature"];
            this.oxygenSaturation = _data["oxygenSaturation"];
            this.height = _data["height"];
            this.weight = _data["weight"];
            this.bmi = _data["bmi"];
            this.dateRecorded = _data["dateRecorded"] ? moment(_data["dateRecorded"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PatientVitalsDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientVitalsDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bloodPressure"] = this.bloodPressure;
        data["heartRate"] = this.heartRate;
        data["respirationRate"] = this.respirationRate;
        data["temperature"] = this.temperature;
        data["oxygenSaturation"] = this.oxygenSaturation;
        data["height"] = this.height;
        data["weight"] = this.weight;
        data["bmi"] = this.bmi;
        data["dateRecorded"] = this.dateRecorded ? this.dateRecorded.toISOString() : <any>undefined;
        return data;
    }

    clone(): PatientVitalsDetailsDto {
        const json = this.toJSON();
        let result = new PatientVitalsDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IPatientVitalsDetailsDto {
    bloodPressure: string | undefined;
    heartRate: string | undefined;
    respirationRate: number;
    temperature: number;
    oxygenSaturation: number;
    height: string | undefined;
    weight: string | undefined;
    bmi: string | undefined;
    dateRecorded: moment.Moment | undefined;
}

export class PatientsForDoctorAndNurseDto implements IPatientsForDoctorAndNurseDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    dateOfBirth: moment.Moment;
    emailAddress: string | undefined;
    gender: string | undefined;
    address: string | undefined;
    bloodGroup: string | undefined;
    emergencyContactName: string | undefined;
    emergencyContactNumber: string | undefined;
    assignedNurseId: number | undefined;
    nurseName: string | undefined;
    assignedDoctorId: number | undefined;
    doctorName: string | undefined;
    abpUserId: number;
    isActive: boolean;
    admissionDate: moment.Moment | undefined;
    billingMethod: BillingMethod;
    paymentMethod: PaymentMethod;

    constructor(data?: IPatientsForDoctorAndNurseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.emailAddress = _data["emailAddress"];
            this.gender = _data["gender"];
            this.address = _data["address"];
            this.bloodGroup = _data["bloodGroup"];
            this.emergencyContactName = _data["emergencyContactName"];
            this.emergencyContactNumber = _data["emergencyContactNumber"];
            this.assignedNurseId = _data["assignedNurseId"];
            this.nurseName = _data["nurseName"];
            this.assignedDoctorId = _data["assignedDoctorId"];
            this.doctorName = _data["doctorName"];
            this.abpUserId = _data["abpUserId"];
            this.isActive = _data["isActive"];
            this.admissionDate = _data["admissionDate"] ? moment(_data["admissionDate"].toString()) : <any>undefined;
            this.billingMethod = _data["billingMethod"];
            this.paymentMethod = _data["paymentMethod"];
        }
    }

    static fromJS(data: any): PatientsForDoctorAndNurseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientsForDoctorAndNurseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["emailAddress"] = this.emailAddress;
        data["gender"] = this.gender;
        data["address"] = this.address;
        data["bloodGroup"] = this.bloodGroup;
        data["emergencyContactName"] = this.emergencyContactName;
        data["emergencyContactNumber"] = this.emergencyContactNumber;
        data["assignedNurseId"] = this.assignedNurseId;
        data["nurseName"] = this.nurseName;
        data["assignedDoctorId"] = this.assignedDoctorId;
        data["doctorName"] = this.doctorName;
        data["abpUserId"] = this.abpUserId;
        data["isActive"] = this.isActive;
        data["admissionDate"] = this.admissionDate ? this.admissionDate.toISOString() : <any>undefined;
        data["billingMethod"] = this.billingMethod;
        data["paymentMethod"] = this.paymentMethod;
        return data;
    }

    clone(): PatientsForDoctorAndNurseDto {
        const json = this.toJSON();
        let result = new PatientsForDoctorAndNurseDto();
        result.init(json);
        return result;
    }
}

export interface IPatientsForDoctorAndNurseDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    dateOfBirth: moment.Moment;
    emailAddress: string | undefined;
    gender: string | undefined;
    address: string | undefined;
    bloodGroup: string | undefined;
    emergencyContactName: string | undefined;
    emergencyContactNumber: string | undefined;
    assignedNurseId: number | undefined;
    nurseName: string | undefined;
    assignedDoctorId: number | undefined;
    doctorName: string | undefined;
    abpUserId: number;
    isActive: boolean;
    admissionDate: moment.Moment | undefined;
    billingMethod: BillingMethod;
    paymentMethod: PaymentMethod;
}

export class PatientsForDoctorAndNurseDtoPagedResultDto implements IPatientsForDoctorAndNurseDtoPagedResultDto {
    items: PatientsForDoctorAndNurseDto[] | undefined;
    totalCount: number;

    constructor(data?: IPatientsForDoctorAndNurseDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PatientsForDoctorAndNurseDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PatientsForDoctorAndNurseDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientsForDoctorAndNurseDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PatientsForDoctorAndNurseDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PatientsForDoctorAndNurseDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPatientsForDoctorAndNurseDtoPagedResultDto {
    items: PatientsForDoctorAndNurseDto[] | undefined;
    totalCount: number;
}

export enum PaymentMethod {
    _0 = 0,
    _1 = 1,
}

export enum PaymentMode {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum PaymentStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class PermissionDto implements IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class Pharmacist implements IPharmacist {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    qualification: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    licenseNumber: string | undefined;
    licenseExpiryDate: moment.Moment;
    abpUserId: number;
    abpUser: User;

    constructor(data?: IPharmacist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.qualification = _data["qualification"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.licenseNumber = _data["licenseNumber"];
            this.licenseExpiryDate = _data["licenseExpiryDate"] ? moment(_data["licenseExpiryDate"].toString()) : <any>undefined;
            this.abpUserId = _data["abpUserId"];
            this.abpUser = _data["abpUser"] ? User.fromJS(_data["abpUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Pharmacist {
        data = typeof data === 'object' ? data : {};
        let result = new Pharmacist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["qualification"] = this.qualification;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["licenseNumber"] = this.licenseNumber;
        data["licenseExpiryDate"] = this.licenseExpiryDate ? this.licenseExpiryDate.toISOString() : <any>undefined;
        data["abpUserId"] = this.abpUserId;
        data["abpUser"] = this.abpUser ? this.abpUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): Pharmacist {
        const json = this.toJSON();
        let result = new Pharmacist();
        result.init(json);
        return result;
    }
}

export interface IPharmacist {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    qualification: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    licenseNumber: string | undefined;
    licenseExpiryDate: moment.Moment;
    abpUserId: number;
    abpUser: User;
}

export class PharmacistDto implements IPharmacistDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    qualification: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    licenseNumber: string | undefined;
    licenseExpiryDate: moment.Moment;
    abpUser: UserDto;

    constructor(data?: IPharmacistDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.qualification = _data["qualification"];
            this.dateOfBirth = _data["dateOfBirth"] ? moment(_data["dateOfBirth"].toString()) : <any>undefined;
            this.licenseNumber = _data["licenseNumber"];
            this.licenseExpiryDate = _data["licenseExpiryDate"] ? moment(_data["licenseExpiryDate"].toString()) : <any>undefined;
            this.abpUser = _data["abpUser"] ? UserDto.fromJS(_data["abpUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PharmacistDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacistDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["qualification"] = this.qualification;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["licenseNumber"] = this.licenseNumber;
        data["licenseExpiryDate"] = this.licenseExpiryDate ? this.licenseExpiryDate.toISOString() : <any>undefined;
        data["abpUser"] = this.abpUser ? this.abpUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): PharmacistDto {
        const json = this.toJSON();
        let result = new PharmacistDto();
        result.init(json);
        return result;
    }
}

export interface IPharmacistDto {
    id: number;
    tenantId: number;
    fullName: string | undefined;
    gender: string | undefined;
    qualification: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    licenseNumber: string | undefined;
    licenseExpiryDate: moment.Moment;
    abpUser: UserDto;
}

export class PharmacistDtoPagedResultDto implements IPharmacistDtoPagedResultDto {
    items: PharmacistDto[] | undefined;
    totalCount: number;

    constructor(data?: IPharmacistDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PharmacistDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PharmacistDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacistDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PharmacistDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PharmacistDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPharmacistDtoPagedResultDto {
    items: PharmacistDto[] | undefined;
    totalCount: number;
}

export class PharmacistInventory implements IPharmacistInventory {
    id: number;
    tenantId: number;
    medicineName: string | undefined;
    costPrice: number;
    sellingPrice: number;
    expiryDate: moment.Moment;
    purchaseDate: moment.Moment;
    unit: string | undefined;
    stock: number;
    minStock: number;
    description: string | undefined;
    isAvailable: boolean;
    readonly stockStatus: string | undefined;
    readonly expiryStatus: string | undefined;

    constructor(data?: IPharmacistInventory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.medicineName = _data["medicineName"];
            this.costPrice = _data["costPrice"];
            this.sellingPrice = _data["sellingPrice"];
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.purchaseDate = _data["purchaseDate"] ? moment(_data["purchaseDate"].toString()) : <any>undefined;
            this.unit = _data["unit"];
            this.stock = _data["stock"];
            this.minStock = _data["minStock"];
            this.description = _data["description"];
            this.isAvailable = _data["isAvailable"];
            (<any>this).stockStatus = _data["stockStatus"];
            (<any>this).expiryStatus = _data["expiryStatus"];
        }
    }

    static fromJS(data: any): PharmacistInventory {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacistInventory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["medicineName"] = this.medicineName;
        data["costPrice"] = this.costPrice;
        data["sellingPrice"] = this.sellingPrice;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toISOString() : <any>undefined;
        data["unit"] = this.unit;
        data["stock"] = this.stock;
        data["minStock"] = this.minStock;
        data["description"] = this.description;
        data["isAvailable"] = this.isAvailable;
        data["stockStatus"] = this.stockStatus;
        data["expiryStatus"] = this.expiryStatus;
        return data;
    }

    clone(): PharmacistInventory {
        const json = this.toJSON();
        let result = new PharmacistInventory();
        result.init(json);
        return result;
    }
}

export interface IPharmacistInventory {
    id: number;
    tenantId: number;
    medicineName: string | undefined;
    costPrice: number;
    sellingPrice: number;
    expiryDate: moment.Moment;
    purchaseDate: moment.Moment;
    unit: string | undefined;
    stock: number;
    minStock: number;
    description: string | undefined;
    isAvailable: boolean;
    stockStatus: string | undefined;
    expiryStatus: string | undefined;
}

export class PharmacistInventoryDto implements IPharmacistInventoryDto {
    id: number;
    tenantId: number;
    medicineName: string | undefined;
    costPrice: number;
    sellingPrice: number;
    expiryDate: moment.Moment;
    purchaseDate: moment.Moment;
    unit: string | undefined;
    stock: number;
    minStock: number;
    description: string | undefined;
    isAvailable: boolean;
    stockStatus: string | undefined;
    expiryStatus: string | undefined;

    constructor(data?: IPharmacistInventoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.medicineName = _data["medicineName"];
            this.costPrice = _data["costPrice"];
            this.sellingPrice = _data["sellingPrice"];
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.purchaseDate = _data["purchaseDate"] ? moment(_data["purchaseDate"].toString()) : <any>undefined;
            this.unit = _data["unit"];
            this.stock = _data["stock"];
            this.minStock = _data["minStock"];
            this.description = _data["description"];
            this.isAvailable = _data["isAvailable"];
            this.stockStatus = _data["stockStatus"];
            this.expiryStatus = _data["expiryStatus"];
        }
    }

    static fromJS(data: any): PharmacistInventoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacistInventoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["medicineName"] = this.medicineName;
        data["costPrice"] = this.costPrice;
        data["sellingPrice"] = this.sellingPrice;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toISOString() : <any>undefined;
        data["unit"] = this.unit;
        data["stock"] = this.stock;
        data["minStock"] = this.minStock;
        data["description"] = this.description;
        data["isAvailable"] = this.isAvailable;
        data["stockStatus"] = this.stockStatus;
        data["expiryStatus"] = this.expiryStatus;
        return data;
    }

    clone(): PharmacistInventoryDto {
        const json = this.toJSON();
        let result = new PharmacistInventoryDto();
        result.init(json);
        return result;
    }
}

export interface IPharmacistInventoryDto {
    id: number;
    tenantId: number;
    medicineName: string | undefined;
    costPrice: number;
    sellingPrice: number;
    expiryDate: moment.Moment;
    purchaseDate: moment.Moment;
    unit: string | undefined;
    stock: number;
    minStock: number;
    description: string | undefined;
    isAvailable: boolean;
    stockStatus: string | undefined;
    expiryStatus: string | undefined;
}

export class PharmacistInventoryDtoPagedResultDto implements IPharmacistInventoryDtoPagedResultDto {
    items: PharmacistInventoryDto[] | undefined;
    totalCount: number;

    constructor(data?: IPharmacistInventoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PharmacistInventoryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PharmacistInventoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacistInventoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PharmacistInventoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PharmacistInventoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPharmacistInventoryDtoPagedResultDto {
    items: PharmacistInventoryDto[] | undefined;
    totalCount: number;
}

export class Prescription implements IPrescription {
    id: number;
    tenantId: number;
    diagnosis: string | undefined;
    notes: string | undefined;
    issueDate: moment.Moment;
    isFollowUpRequired: boolean;
    appointmentId: number;
    appointment: Appointment;
    doctorId: number;
    doctor: Doctor;
    patientId: number;
    patient: Patient;
    items: PrescriptionItem[] | undefined;
    labTests: PrescriptionLabTest[] | undefined;

    constructor(data?: IPrescription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.diagnosis = _data["diagnosis"];
            this.notes = _data["notes"];
            this.issueDate = _data["issueDate"] ? moment(_data["issueDate"].toString()) : <any>undefined;
            this.isFollowUpRequired = _data["isFollowUpRequired"];
            this.appointmentId = _data["appointmentId"];
            this.appointment = _data["appointment"] ? Appointment.fromJS(_data["appointment"]) : <any>undefined;
            this.doctorId = _data["doctorId"];
            this.doctor = _data["doctor"] ? Doctor.fromJS(_data["doctor"]) : <any>undefined;
            this.patientId = _data["patientId"];
            this.patient = _data["patient"] ? Patient.fromJS(_data["patient"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PrescriptionItem.fromJS(item));
            }
            if (Array.isArray(_data["labTests"])) {
                this.labTests = [] as any;
                for (let item of _data["labTests"])
                    this.labTests.push(PrescriptionLabTest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Prescription {
        data = typeof data === 'object' ? data : {};
        let result = new Prescription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["diagnosis"] = this.diagnosis;
        data["notes"] = this.notes;
        data["issueDate"] = this.issueDate ? this.issueDate.toISOString() : <any>undefined;
        data["isFollowUpRequired"] = this.isFollowUpRequired;
        data["appointmentId"] = this.appointmentId;
        data["appointment"] = this.appointment ? this.appointment.toJSON() : <any>undefined;
        data["doctorId"] = this.doctorId;
        data["doctor"] = this.doctor ? this.doctor.toJSON() : <any>undefined;
        data["patientId"] = this.patientId;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.labTests)) {
            data["labTests"] = [];
            for (let item of this.labTests)
                data["labTests"].push(item.toJSON());
        }
        return data;
    }

    clone(): Prescription {
        const json = this.toJSON();
        let result = new Prescription();
        result.init(json);
        return result;
    }
}

export interface IPrescription {
    id: number;
    tenantId: number;
    diagnosis: string | undefined;
    notes: string | undefined;
    issueDate: moment.Moment;
    isFollowUpRequired: boolean;
    appointmentId: number;
    appointment: Appointment;
    doctorId: number;
    doctor: Doctor;
    patientId: number;
    patient: Patient;
    items: PrescriptionItem[] | undefined;
    labTests: PrescriptionLabTest[] | undefined;
}

export class PrescriptionDto implements IPrescriptionDto {
    id: number;
    tenantId: number;
    diagnosis: string | undefined;
    notes: string | undefined;
    issueDate: moment.Moment;
    isFollowUpRequired: boolean;
    appointment: AppointmentDto;
    doctor: DoctorDto;
    patient: PatientDto;
    items: PrescriptionItemDto[] | undefined;
    labTestIds: number[] | undefined;
    labTests: PrescriptionLabTestDto[] | undefined;

    constructor(data?: IPrescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.diagnosis = _data["diagnosis"];
            this.notes = _data["notes"];
            this.issueDate = _data["issueDate"] ? moment(_data["issueDate"].toString()) : <any>undefined;
            this.isFollowUpRequired = _data["isFollowUpRequired"];
            this.appointment = _data["appointment"] ? AppointmentDto.fromJS(_data["appointment"]) : <any>undefined;
            this.doctor = _data["doctor"] ? DoctorDto.fromJS(_data["doctor"]) : <any>undefined;
            this.patient = _data["patient"] ? PatientDto.fromJS(_data["patient"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PrescriptionItemDto.fromJS(item));
            }
            if (Array.isArray(_data["labTestIds"])) {
                this.labTestIds = [] as any;
                for (let item of _data["labTestIds"])
                    this.labTestIds.push(item);
            }
            if (Array.isArray(_data["labTests"])) {
                this.labTests = [] as any;
                for (let item of _data["labTests"])
                    this.labTests.push(PrescriptionLabTestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["diagnosis"] = this.diagnosis;
        data["notes"] = this.notes;
        data["issueDate"] = this.issueDate ? this.issueDate.toISOString() : <any>undefined;
        data["isFollowUpRequired"] = this.isFollowUpRequired;
        data["appointment"] = this.appointment ? this.appointment.toJSON() : <any>undefined;
        data["doctor"] = this.doctor ? this.doctor.toJSON() : <any>undefined;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.labTestIds)) {
            data["labTestIds"] = [];
            for (let item of this.labTestIds)
                data["labTestIds"].push(item);
        }
        if (Array.isArray(this.labTests)) {
            data["labTests"] = [];
            for (let item of this.labTests)
                data["labTests"].push(item.toJSON());
        }
        return data;
    }

    clone(): PrescriptionDto {
        const json = this.toJSON();
        let result = new PrescriptionDto();
        result.init(json);
        return result;
    }
}

export interface IPrescriptionDto {
    id: number;
    tenantId: number;
    diagnosis: string | undefined;
    notes: string | undefined;
    issueDate: moment.Moment;
    isFollowUpRequired: boolean;
    appointment: AppointmentDto;
    doctor: DoctorDto;
    patient: PatientDto;
    items: PrescriptionItemDto[] | undefined;
    labTestIds: number[] | undefined;
    labTests: PrescriptionLabTestDto[] | undefined;
}

export class PrescriptionDtoPagedResultDto implements IPrescriptionDtoPagedResultDto {
    items: PrescriptionDto[] | undefined;
    totalCount: number;

    constructor(data?: IPrescriptionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PrescriptionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PrescriptionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrescriptionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PrescriptionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PrescriptionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPrescriptionDtoPagedResultDto {
    items: PrescriptionDto[] | undefined;
    totalCount: number;
}

export class PrescriptionItem implements IPrescriptionItem {
    id: number;
    medicineName: string | undefined;
    dosage: string | undefined;
    frequency: string | undefined;
    duration: string | undefined;
    instructions: string | undefined;
    prescriptionId: number;
    medicineId: number;
    prescription: Prescription;

    constructor(data?: IPrescriptionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.medicineName = _data["medicineName"];
            this.dosage = _data["dosage"];
            this.frequency = _data["frequency"];
            this.duration = _data["duration"];
            this.instructions = _data["instructions"];
            this.prescriptionId = _data["prescriptionId"];
            this.medicineId = _data["medicineId"];
            this.prescription = _data["prescription"] ? Prescription.fromJS(_data["prescription"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PrescriptionItem {
        data = typeof data === 'object' ? data : {};
        let result = new PrescriptionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["medicineName"] = this.medicineName;
        data["dosage"] = this.dosage;
        data["frequency"] = this.frequency;
        data["duration"] = this.duration;
        data["instructions"] = this.instructions;
        data["prescriptionId"] = this.prescriptionId;
        data["medicineId"] = this.medicineId;
        data["prescription"] = this.prescription ? this.prescription.toJSON() : <any>undefined;
        return data;
    }

    clone(): PrescriptionItem {
        const json = this.toJSON();
        let result = new PrescriptionItem();
        result.init(json);
        return result;
    }
}

export interface IPrescriptionItem {
    id: number;
    medicineName: string | undefined;
    dosage: string | undefined;
    frequency: string | undefined;
    duration: string | undefined;
    instructions: string | undefined;
    prescriptionId: number;
    medicineId: number;
    prescription: Prescription;
}

export class PrescriptionItemDto implements IPrescriptionItemDto {
    id: number;
    tenantId: number;
    medicineName: string | undefined;
    dosage: string | undefined;
    frequency: string | undefined;
    duration: string | undefined;
    instructions: string | undefined;
    medicineId: number;
    prescription: PrescriptionDto;

    constructor(data?: IPrescriptionItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.medicineName = _data["medicineName"];
            this.dosage = _data["dosage"];
            this.frequency = _data["frequency"];
            this.duration = _data["duration"];
            this.instructions = _data["instructions"];
            this.medicineId = _data["medicineId"];
            this.prescription = _data["prescription"] ? PrescriptionDto.fromJS(_data["prescription"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PrescriptionItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrescriptionItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["medicineName"] = this.medicineName;
        data["dosage"] = this.dosage;
        data["frequency"] = this.frequency;
        data["duration"] = this.duration;
        data["instructions"] = this.instructions;
        data["medicineId"] = this.medicineId;
        data["prescription"] = this.prescription ? this.prescription.toJSON() : <any>undefined;
        return data;
    }

    clone(): PrescriptionItemDto {
        const json = this.toJSON();
        let result = new PrescriptionItemDto();
        result.init(json);
        return result;
    }
}

export interface IPrescriptionItemDto {
    id: number;
    tenantId: number;
    medicineName: string | undefined;
    dosage: string | undefined;
    frequency: string | undefined;
    duration: string | undefined;
    instructions: string | undefined;
    medicineId: number;
    prescription: PrescriptionDto;
}

export class PrescriptionItemDtoPagedResultDto implements IPrescriptionItemDtoPagedResultDto {
    items: PrescriptionItemDto[] | undefined;
    totalCount: number;

    constructor(data?: IPrescriptionItemDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PrescriptionItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PrescriptionItemDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrescriptionItemDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PrescriptionItemDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PrescriptionItemDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPrescriptionItemDtoPagedResultDto {
    items: PrescriptionItemDto[] | undefined;
    totalCount: number;
}

export class PrescriptionLabTest implements IPrescriptionLabTest {
    id: number;
    tenantId: number;
    prescriptionId: number;
    prescription: Prescription;
    labReportsTypeId: number;
    labReportsType: LabReportsType;
    testStatus: LabTestStatus;
    createdDate: moment.Moment | undefined;
    labReportResultItems: LabReportResultItem[] | undefined;

    constructor(data?: IPrescriptionLabTest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.prescriptionId = _data["prescriptionId"];
            this.prescription = _data["prescription"] ? Prescription.fromJS(_data["prescription"]) : <any>undefined;
            this.labReportsTypeId = _data["labReportsTypeId"];
            this.labReportsType = _data["labReportsType"] ? LabReportsType.fromJS(_data["labReportsType"]) : <any>undefined;
            this.testStatus = _data["testStatus"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["labReportResultItems"])) {
                this.labReportResultItems = [] as any;
                for (let item of _data["labReportResultItems"])
                    this.labReportResultItems.push(LabReportResultItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrescriptionLabTest {
        data = typeof data === 'object' ? data : {};
        let result = new PrescriptionLabTest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["prescriptionId"] = this.prescriptionId;
        data["prescription"] = this.prescription ? this.prescription.toJSON() : <any>undefined;
        data["labReportsTypeId"] = this.labReportsTypeId;
        data["labReportsType"] = this.labReportsType ? this.labReportsType.toJSON() : <any>undefined;
        data["testStatus"] = this.testStatus;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        if (Array.isArray(this.labReportResultItems)) {
            data["labReportResultItems"] = [];
            for (let item of this.labReportResultItems)
                data["labReportResultItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): PrescriptionLabTest {
        const json = this.toJSON();
        let result = new PrescriptionLabTest();
        result.init(json);
        return result;
    }
}

export interface IPrescriptionLabTest {
    id: number;
    tenantId: number;
    prescriptionId: number;
    prescription: Prescription;
    labReportsTypeId: number;
    labReportsType: LabReportsType;
    testStatus: LabTestStatus;
    createdDate: moment.Moment | undefined;
    labReportResultItems: LabReportResultItem[] | undefined;
}

export class PrescriptionLabTestDto implements IPrescriptionLabTestDto {
    id: number;
    tenantId: number;
    prescriptionId: number;
    labReportsTypeId: number;
    reportTypeName: string | undefined;

    constructor(data?: IPrescriptionLabTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.prescriptionId = _data["prescriptionId"];
            this.labReportsTypeId = _data["labReportsTypeId"];
            this.reportTypeName = _data["reportTypeName"];
        }
    }

    static fromJS(data: any): PrescriptionLabTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrescriptionLabTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["prescriptionId"] = this.prescriptionId;
        data["labReportsTypeId"] = this.labReportsTypeId;
        data["reportTypeName"] = this.reportTypeName;
        return data;
    }

    clone(): PrescriptionLabTestDto {
        const json = this.toJSON();
        let result = new PrescriptionLabTestDto();
        result.init(json);
        return result;
    }
}

export interface IPrescriptionLabTestDto {
    id: number;
    tenantId: number;
    prescriptionId: number;
    labReportsTypeId: number;
    reportTypeName: string | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class RoleDto implements IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;
}

export class RoleEditDto implements IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        return data;
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
}

export class RoleListDto implements IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class Room implements IRoom {
    id: number;
    tenantId: number;
    roomNumber: string | undefined;
    floor: number;
    roomTypeMasterId: number;
    roomTypeMaster: RoomTypeMaster;
    admissions: Admission[] | undefined;
    status: RoomStatus;

    constructor(data?: IRoom) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.roomNumber = _data["roomNumber"];
            this.floor = _data["floor"];
            this.roomTypeMasterId = _data["roomTypeMasterId"];
            this.roomTypeMaster = _data["roomTypeMaster"] ? RoomTypeMaster.fromJS(_data["roomTypeMaster"]) : <any>undefined;
            if (Array.isArray(_data["admissions"])) {
                this.admissions = [] as any;
                for (let item of _data["admissions"])
                    this.admissions.push(Admission.fromJS(item));
            }
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Room {
        data = typeof data === 'object' ? data : {};
        let result = new Room();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["roomNumber"] = this.roomNumber;
        data["floor"] = this.floor;
        data["roomTypeMasterId"] = this.roomTypeMasterId;
        data["roomTypeMaster"] = this.roomTypeMaster ? this.roomTypeMaster.toJSON() : <any>undefined;
        if (Array.isArray(this.admissions)) {
            data["admissions"] = [];
            for (let item of this.admissions)
                data["admissions"].push(item.toJSON());
        }
        data["status"] = this.status;
        return data;
    }

    clone(): Room {
        const json = this.toJSON();
        let result = new Room();
        result.init(json);
        return result;
    }
}

export interface IRoom {
    id: number;
    tenantId: number;
    roomNumber: string | undefined;
    floor: number;
    roomTypeMasterId: number;
    roomTypeMaster: RoomTypeMaster;
    admissions: Admission[] | undefined;
    status: RoomStatus;
}

export class RoomDto implements IRoomDto {
    id: number;
    tenantId: number;
    roomNumber: string | undefined;
    floor: number;
    roomTypeMasterId: number;
    roomTypeName: string | undefined;
    status: RoomStatus;

    constructor(data?: IRoomDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.roomNumber = _data["roomNumber"];
            this.floor = _data["floor"];
            this.roomTypeMasterId = _data["roomTypeMasterId"];
            this.roomTypeName = _data["roomTypeName"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): RoomDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["roomNumber"] = this.roomNumber;
        data["floor"] = this.floor;
        data["roomTypeMasterId"] = this.roomTypeMasterId;
        data["roomTypeName"] = this.roomTypeName;
        data["status"] = this.status;
        return data;
    }

    clone(): RoomDto {
        const json = this.toJSON();
        let result = new RoomDto();
        result.init(json);
        return result;
    }
}

export interface IRoomDto {
    id: number;
    tenantId: number;
    roomNumber: string | undefined;
    floor: number;
    roomTypeMasterId: number;
    roomTypeName: string | undefined;
    status: RoomStatus;
}

export class RoomDtoPagedResultDto implements IRoomDtoPagedResultDto {
    items: RoomDto[] | undefined;
    totalCount: number;

    constructor(data?: IRoomDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoomDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RoomDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RoomDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoomDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoomDtoPagedResultDto {
    items: RoomDto[] | undefined;
    totalCount: number;
}

export class RoomFacilityMaster implements IRoomFacilityMaster {
    id: number;
    tenantId: number;
    facilityName: string;

    constructor(data?: IRoomFacilityMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.facilityName = _data["facilityName"];
        }
    }

    static fromJS(data: any): RoomFacilityMaster {
        data = typeof data === 'object' ? data : {};
        let result = new RoomFacilityMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["facilityName"] = this.facilityName;
        return data;
    }

    clone(): RoomFacilityMaster {
        const json = this.toJSON();
        let result = new RoomFacilityMaster();
        result.init(json);
        return result;
    }
}

export interface IRoomFacilityMaster {
    id: number;
    tenantId: number;
    facilityName: string;
}

export class RoomFacilityMasterDto implements IRoomFacilityMasterDto {
    id: number;
    tenantId: number;
    facilityName: string | undefined;

    constructor(data?: IRoomFacilityMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.facilityName = _data["facilityName"];
        }
    }

    static fromJS(data: any): RoomFacilityMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomFacilityMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["facilityName"] = this.facilityName;
        return data;
    }

    clone(): RoomFacilityMasterDto {
        const json = this.toJSON();
        let result = new RoomFacilityMasterDto();
        result.init(json);
        return result;
    }
}

export interface IRoomFacilityMasterDto {
    id: number;
    tenantId: number;
    facilityName: string | undefined;
}

export class RoomFacilityMasterDtoListResultDto implements IRoomFacilityMasterDtoListResultDto {
    items: RoomFacilityMasterDto[] | undefined;

    constructor(data?: IRoomFacilityMasterDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoomFacilityMasterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoomFacilityMasterDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomFacilityMasterDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoomFacilityMasterDtoListResultDto {
        const json = this.toJSON();
        let result = new RoomFacilityMasterDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoomFacilityMasterDtoListResultDto {
    items: RoomFacilityMasterDto[] | undefined;
}

export class RoomFacilityMasterDtoPagedResultDto implements IRoomFacilityMasterDtoPagedResultDto {
    items: RoomFacilityMasterDto[] | undefined;
    totalCount: number;

    constructor(data?: IRoomFacilityMasterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoomFacilityMasterDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RoomFacilityMasterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomFacilityMasterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RoomFacilityMasterDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoomFacilityMasterDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoomFacilityMasterDtoPagedResultDto {
    items: RoomFacilityMasterDto[] | undefined;
    totalCount: number;
}

export enum RoomStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class RoomTypeFacility implements IRoomTypeFacility {
    id: number;
    tenantId: number;
    roomTypeMasterId: number;
    roomTypeMaster: RoomTypeMaster;
    roomFacilityMasterId: number;
    roomFacilityMaster: RoomFacilityMaster;

    constructor(data?: IRoomTypeFacility) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.roomTypeMasterId = _data["roomTypeMasterId"];
            this.roomTypeMaster = _data["roomTypeMaster"] ? RoomTypeMaster.fromJS(_data["roomTypeMaster"]) : <any>undefined;
            this.roomFacilityMasterId = _data["roomFacilityMasterId"];
            this.roomFacilityMaster = _data["roomFacilityMaster"] ? RoomFacilityMaster.fromJS(_data["roomFacilityMaster"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RoomTypeFacility {
        data = typeof data === 'object' ? data : {};
        let result = new RoomTypeFacility();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["roomTypeMasterId"] = this.roomTypeMasterId;
        data["roomTypeMaster"] = this.roomTypeMaster ? this.roomTypeMaster.toJSON() : <any>undefined;
        data["roomFacilityMasterId"] = this.roomFacilityMasterId;
        data["roomFacilityMaster"] = this.roomFacilityMaster ? this.roomFacilityMaster.toJSON() : <any>undefined;
        return data;
    }

    clone(): RoomTypeFacility {
        const json = this.toJSON();
        let result = new RoomTypeFacility();
        result.init(json);
        return result;
    }
}

export interface IRoomTypeFacility {
    id: number;
    tenantId: number;
    roomTypeMasterId: number;
    roomTypeMaster: RoomTypeMaster;
    roomFacilityMasterId: number;
    roomFacilityMaster: RoomFacilityMaster;
}

export class RoomTypeMaster implements IRoomTypeMaster {
    id: number;
    tenantId: number;
    typeName: string;
    description: string | undefined;
    defaultPricePerDay: number;
    facilities: RoomTypeFacility[] | undefined;

    constructor(data?: IRoomTypeMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.typeName = _data["typeName"];
            this.description = _data["description"];
            this.defaultPricePerDay = _data["defaultPricePerDay"];
            if (Array.isArray(_data["facilities"])) {
                this.facilities = [] as any;
                for (let item of _data["facilities"])
                    this.facilities.push(RoomTypeFacility.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoomTypeMaster {
        data = typeof data === 'object' ? data : {};
        let result = new RoomTypeMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["typeName"] = this.typeName;
        data["description"] = this.description;
        data["defaultPricePerDay"] = this.defaultPricePerDay;
        if (Array.isArray(this.facilities)) {
            data["facilities"] = [];
            for (let item of this.facilities)
                data["facilities"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoomTypeMaster {
        const json = this.toJSON();
        let result = new RoomTypeMaster();
        result.init(json);
        return result;
    }
}

export interface IRoomTypeMaster {
    id: number;
    tenantId: number;
    typeName: string;
    description: string | undefined;
    defaultPricePerDay: number;
    facilities: RoomTypeFacility[] | undefined;
}

export class RoomTypeMasterDto implements IRoomTypeMasterDto {
    id: number;
    tenantId: number;
    typeName: string | undefined;
    description: string | undefined;
    defaultPricePerDay: number;
    facilityIds: number[] | undefined;
    facilities: RoomFacilityMasterDto[] | undefined;

    constructor(data?: IRoomTypeMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.typeName = _data["typeName"];
            this.description = _data["description"];
            this.defaultPricePerDay = _data["defaultPricePerDay"];
            if (Array.isArray(_data["facilityIds"])) {
                this.facilityIds = [] as any;
                for (let item of _data["facilityIds"])
                    this.facilityIds.push(item);
            }
            if (Array.isArray(_data["facilities"])) {
                this.facilities = [] as any;
                for (let item of _data["facilities"])
                    this.facilities.push(RoomFacilityMasterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoomTypeMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomTypeMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["typeName"] = this.typeName;
        data["description"] = this.description;
        data["defaultPricePerDay"] = this.defaultPricePerDay;
        if (Array.isArray(this.facilityIds)) {
            data["facilityIds"] = [];
            for (let item of this.facilityIds)
                data["facilityIds"].push(item);
        }
        if (Array.isArray(this.facilities)) {
            data["facilities"] = [];
            for (let item of this.facilities)
                data["facilities"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoomTypeMasterDto {
        const json = this.toJSON();
        let result = new RoomTypeMasterDto();
        result.init(json);
        return result;
    }
}

export interface IRoomTypeMasterDto {
    id: number;
    tenantId: number;
    typeName: string | undefined;
    description: string | undefined;
    defaultPricePerDay: number;
    facilityIds: number[] | undefined;
    facilities: RoomFacilityMasterDto[] | undefined;
}

export class RoomTypeMasterDtoListResultDto implements IRoomTypeMasterDtoListResultDto {
    items: RoomTypeMasterDto[] | undefined;

    constructor(data?: IRoomTypeMasterDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoomTypeMasterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoomTypeMasterDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomTypeMasterDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoomTypeMasterDtoListResultDto {
        const json = this.toJSON();
        let result = new RoomTypeMasterDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoomTypeMasterDtoListResultDto {
    items: RoomTypeMasterDto[] | undefined;
}

export class RoomTypeMasterDtoPagedResultDto implements IRoomTypeMasterDtoPagedResultDto {
    items: RoomTypeMasterDto[] | undefined;
    totalCount: number;

    constructor(data?: IRoomTypeMasterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoomTypeMasterDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RoomTypeMasterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomTypeMasterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RoomTypeMasterDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoomTypeMasterDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoomTypeMasterDtoPagedResultDto {
    items: RoomTypeMasterDto[] | undefined;
    totalCount: number;
}

export class Setting implements ISetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TenantDto implements ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data;
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;
}

export class User implements IUser {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    readonly fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    patients: Patient[] | undefined;
    bills: Bill[] | undefined;
    doctors: Doctor[] | undefined;
    nurses: Nurse[] | undefined;
    pharmacists: Pharmacist[] | undefined;
    labTechnicians: LabTechnician[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.authenticationSource = _data["authenticationSource"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            (<any>this).fullName = _data["fullName"];
            this.password = _data["password"];
            this.emailConfirmationCode = _data["emailConfirmationCode"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? moment(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = _data["accessFailedCount"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.securityStamp = _data["securityStamp"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.isActive = _data["isActive"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.normalizedEmailAddress = _data["normalizedEmailAddress"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            if (Array.isArray(_data["patients"])) {
                this.patients = [] as any;
                for (let item of _data["patients"])
                    this.patients.push(Patient.fromJS(item));
            }
            if (Array.isArray(_data["bills"])) {
                this.bills = [] as any;
                for (let item of _data["bills"])
                    this.bills.push(Bill.fromJS(item));
            }
            if (Array.isArray(_data["doctors"])) {
                this.doctors = [] as any;
                for (let item of _data["doctors"])
                    this.doctors.push(Doctor.fromJS(item));
            }
            if (Array.isArray(_data["nurses"])) {
                this.nurses = [] as any;
                for (let item of _data["nurses"])
                    this.nurses.push(Nurse.fromJS(item));
            }
            if (Array.isArray(_data["pharmacists"])) {
                this.pharmacists = [] as any;
                for (let item of _data["pharmacists"])
                    this.pharmacists.push(Pharmacist.fromJS(item));
            }
            if (Array.isArray(_data["labTechnicians"])) {
                this.labTechnicians = [] as any;
                for (let item of _data["labTechnicians"])
                    this.labTechnicians.push(LabTechnician.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        if (Array.isArray(this.patients)) {
            data["patients"] = [];
            for (let item of this.patients)
                data["patients"].push(item.toJSON());
        }
        if (Array.isArray(this.bills)) {
            data["bills"] = [];
            for (let item of this.bills)
                data["bills"].push(item.toJSON());
        }
        if (Array.isArray(this.doctors)) {
            data["doctors"] = [];
            for (let item of this.doctors)
                data["doctors"].push(item.toJSON());
        }
        if (Array.isArray(this.nurses)) {
            data["nurses"] = [];
            for (let item of this.nurses)
                data["nurses"].push(item.toJSON());
        }
        if (Array.isArray(this.pharmacists)) {
            data["pharmacists"] = [];
            for (let item of this.pharmacists)
                data["pharmacists"].push(item.toJSON());
        }
        if (Array.isArray(this.labTechnicians)) {
            data["labTechnicians"] = [];
            for (let item of this.labTechnicians)
                data["labTechnicians"].push(item.toJSON());
        }
        return data;
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    patients: Patient[] | undefined;
    bills: Bill[] | undefined;
    doctors: Doctor[] | undefined;
    nurses: Nurse[] | undefined;
    pharmacists: Pharmacist[] | undefined;
    labTechnicians: LabTechnician[] | undefined;
}

export class UserClaim implements IUserClaim {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
}

export class UserDto implements IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;
}

export class UserLogin implements IUserLogin {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        return data;
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    userId: number;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["userId"] = this.userId;
        return data;
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    userId: number;
}

export class UserRole implements IUserRole {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    roleId: number;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data;
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    roleId: number;
}

export class UserToken implements IUserToken {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
}

export class ViewLabReportDto implements IViewLabReportDto {
    id: number;
    tenantName: string | undefined;
    testName: string | undefined;
    prescriptionLabTestId: number;
    patientId: number;
    patientName: string | undefined;
    patientDateOfBirth: string | undefined;
    gender: string | undefined;
    doctorName: string | undefined;
    recordedDate: moment.Moment;
    doctorRegistrationNumber: string | undefined;
    labReportResultItem: LabReportResultItemDto[] | undefined;

    constructor(data?: IViewLabReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantName = _data["tenantName"];
            this.testName = _data["testName"];
            this.prescriptionLabTestId = _data["prescriptionLabTestId"];
            this.patientId = _data["patientId"];
            this.patientName = _data["patientName"];
            this.patientDateOfBirth = _data["patientDateOfBirth"];
            this.gender = _data["gender"];
            this.doctorName = _data["doctorName"];
            this.recordedDate = _data["recordedDate"] ? moment(_data["recordedDate"].toString()) : <any>undefined;
            this.doctorRegistrationNumber = _data["doctorRegistrationNumber"];
            if (Array.isArray(_data["labReportResultItem"])) {
                this.labReportResultItem = [] as any;
                for (let item of _data["labReportResultItem"])
                    this.labReportResultItem.push(LabReportResultItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViewLabReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewLabReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantName"] = this.tenantName;
        data["testName"] = this.testName;
        data["prescriptionLabTestId"] = this.prescriptionLabTestId;
        data["patientId"] = this.patientId;
        data["patientName"] = this.patientName;
        data["patientDateOfBirth"] = this.patientDateOfBirth;
        data["gender"] = this.gender;
        data["doctorName"] = this.doctorName;
        data["recordedDate"] = this.recordedDate ? this.recordedDate.toISOString() : <any>undefined;
        data["doctorRegistrationNumber"] = this.doctorRegistrationNumber;
        if (Array.isArray(this.labReportResultItem)) {
            data["labReportResultItem"] = [];
            for (let item of this.labReportResultItem)
                data["labReportResultItem"].push(item.toJSON());
        }
        return data;
    }

    clone(): ViewLabReportDto {
        const json = this.toJSON();
        let result = new ViewLabReportDto();
        result.init(json);
        return result;
    }
}

export interface IViewLabReportDto {
    id: number;
    tenantName: string | undefined;
    testName: string | undefined;
    prescriptionLabTestId: number;
    patientId: number;
    patientName: string | undefined;
    patientDateOfBirth: string | undefined;
    gender: string | undefined;
    doctorName: string | undefined;
    recordedDate: moment.Moment;
    doctorRegistrationNumber: string | undefined;
    labReportResultItem: LabReportResultItemDto[] | undefined;
}

export class Visit implements IVisit {
    id: number;
    tenantId: number;
    patientId: number;
    patient: Patient;
    departmentId: number;
    department: Department;
    nurseId: number;
    nurse: Nurse;
    doctorId: number;
    doctor: Doctor;
    dateOfVisit: moment.Moment;
    timeOfVisit: string;
    reasonForVisit: string | undefined;
    paymentMode: PaymentMode;
    consultationFee: number | undefined;

    constructor(data?: IVisit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.patientId = _data["patientId"];
            this.patient = _data["patient"] ? Patient.fromJS(_data["patient"]) : <any>undefined;
            this.departmentId = _data["departmentId"];
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.nurseId = _data["nurseId"];
            this.nurse = _data["nurse"] ? Nurse.fromJS(_data["nurse"]) : <any>undefined;
            this.doctorId = _data["doctorId"];
            this.doctor = _data["doctor"] ? Doctor.fromJS(_data["doctor"]) : <any>undefined;
            this.dateOfVisit = _data["dateOfVisit"] ? moment(_data["dateOfVisit"].toString()) : <any>undefined;
            this.timeOfVisit = _data["timeOfVisit"];
            this.reasonForVisit = _data["reasonForVisit"];
            this.paymentMode = _data["paymentMode"];
            this.consultationFee = _data["consultationFee"];
        }
    }

    static fromJS(data: any): Visit {
        data = typeof data === 'object' ? data : {};
        let result = new Visit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["patientId"] = this.patientId;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>undefined;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["nurseId"] = this.nurseId;
        data["nurse"] = this.nurse ? this.nurse.toJSON() : <any>undefined;
        data["doctorId"] = this.doctorId;
        data["doctor"] = this.doctor ? this.doctor.toJSON() : <any>undefined;
        data["dateOfVisit"] = this.dateOfVisit ? this.dateOfVisit.toISOString() : <any>undefined;
        data["timeOfVisit"] = this.timeOfVisit;
        data["reasonForVisit"] = this.reasonForVisit;
        data["paymentMode"] = this.paymentMode;
        data["consultationFee"] = this.consultationFee;
        return data;
    }

    clone(): Visit {
        const json = this.toJSON();
        let result = new Visit();
        result.init(json);
        return result;
    }
}

export interface IVisit {
    id: number;
    tenantId: number;
    patientId: number;
    patient: Patient;
    departmentId: number;
    department: Department;
    nurseId: number;
    nurse: Nurse;
    doctorId: number;
    doctor: Doctor;
    dateOfVisit: moment.Moment;
    timeOfVisit: string;
    reasonForVisit: string | undefined;
    paymentMode: PaymentMode;
    consultationFee: number | undefined;
}

export class VisitListDto implements IVisitListDto {
    id: number;
    patient: PatientDto;
    department: DepartmentListDto;
    doctor: DoctorDto;
    nurse: NurseDto;
    dateOfVisit: moment.Moment;
    timeOfVisit: string;
    reasonForVisit: string | undefined;
    paymentMode: PaymentMode;
    consultationFee: number | undefined;

    constructor(data?: IVisitListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.patient = _data["patient"] ? PatientDto.fromJS(_data["patient"]) : <any>undefined;
            this.department = _data["department"] ? DepartmentListDto.fromJS(_data["department"]) : <any>undefined;
            this.doctor = _data["doctor"] ? DoctorDto.fromJS(_data["doctor"]) : <any>undefined;
            this.nurse = _data["nurse"] ? NurseDto.fromJS(_data["nurse"]) : <any>undefined;
            this.dateOfVisit = _data["dateOfVisit"] ? moment(_data["dateOfVisit"].toString()) : <any>undefined;
            this.timeOfVisit = _data["timeOfVisit"];
            this.reasonForVisit = _data["reasonForVisit"];
            this.paymentMode = _data["paymentMode"];
            this.consultationFee = _data["consultationFee"];
        }
    }

    static fromJS(data: any): VisitListDto {
        data = typeof data === 'object' ? data : {};
        let result = new VisitListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>undefined;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["doctor"] = this.doctor ? this.doctor.toJSON() : <any>undefined;
        data["nurse"] = this.nurse ? this.nurse.toJSON() : <any>undefined;
        data["dateOfVisit"] = this.dateOfVisit ? this.dateOfVisit.toISOString() : <any>undefined;
        data["timeOfVisit"] = this.timeOfVisit;
        data["reasonForVisit"] = this.reasonForVisit;
        data["paymentMode"] = this.paymentMode;
        data["consultationFee"] = this.consultationFee;
        return data;
    }

    clone(): VisitListDto {
        const json = this.toJSON();
        let result = new VisitListDto();
        result.init(json);
        return result;
    }
}

export interface IVisitListDto {
    id: number;
    patient: PatientDto;
    department: DepartmentListDto;
    doctor: DoctorDto;
    nurse: NurseDto;
    dateOfVisit: moment.Moment;
    timeOfVisit: string;
    reasonForVisit: string | undefined;
    paymentMode: PaymentMode;
    consultationFee: number | undefined;
}

export class VisitListDtoPagedResultDto implements IVisitListDtoPagedResultDto {
    items: VisitListDto[] | undefined;
    totalCount: number;

    constructor(data?: IVisitListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(VisitListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VisitListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new VisitListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): VisitListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new VisitListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IVisitListDtoPagedResultDto {
    items: VisitListDto[] | undefined;
    totalCount: number;
}

export class Vital implements IVital {
    id: number;
    tenantId: number;
    dateRecorded: moment.Moment | undefined;
    bloodPressure: string | undefined;
    heartRate: string | undefined;
    respirationRate: number;
    temperature: number;
    oxygenSaturation: number;
    height: string | undefined;
    weight: string | undefined;
    bmi: string | undefined;
    notes: string | undefined;
    patientId: number;
    patient: Patient;
    nurseId: number;
    nurse: Nurse;

    constructor(data?: IVital) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.dateRecorded = _data["dateRecorded"] ? moment(_data["dateRecorded"].toString()) : <any>undefined;
            this.bloodPressure = _data["bloodPressure"];
            this.heartRate = _data["heartRate"];
            this.respirationRate = _data["respirationRate"];
            this.temperature = _data["temperature"];
            this.oxygenSaturation = _data["oxygenSaturation"];
            this.height = _data["height"];
            this.weight = _data["weight"];
            this.bmi = _data["bmi"];
            this.notes = _data["notes"];
            this.patientId = _data["patientId"];
            this.patient = _data["patient"] ? Patient.fromJS(_data["patient"]) : <any>undefined;
            this.nurseId = _data["nurseId"];
            this.nurse = _data["nurse"] ? Nurse.fromJS(_data["nurse"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Vital {
        data = typeof data === 'object' ? data : {};
        let result = new Vital();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["dateRecorded"] = this.dateRecorded ? this.dateRecorded.toISOString() : <any>undefined;
        data["bloodPressure"] = this.bloodPressure;
        data["heartRate"] = this.heartRate;
        data["respirationRate"] = this.respirationRate;
        data["temperature"] = this.temperature;
        data["oxygenSaturation"] = this.oxygenSaturation;
        data["height"] = this.height;
        data["weight"] = this.weight;
        data["bmi"] = this.bmi;
        data["notes"] = this.notes;
        data["patientId"] = this.patientId;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>undefined;
        data["nurseId"] = this.nurseId;
        data["nurse"] = this.nurse ? this.nurse.toJSON() : <any>undefined;
        return data;
    }

    clone(): Vital {
        const json = this.toJSON();
        let result = new Vital();
        result.init(json);
        return result;
    }
}

export interface IVital {
    id: number;
    tenantId: number;
    dateRecorded: moment.Moment | undefined;
    bloodPressure: string | undefined;
    heartRate: string | undefined;
    respirationRate: number;
    temperature: number;
    oxygenSaturation: number;
    height: string | undefined;
    weight: string | undefined;
    bmi: string | undefined;
    notes: string | undefined;
    patientId: number;
    patient: Patient;
    nurseId: number;
    nurse: Nurse;
}

export class VitalDto implements IVitalDto {
    id: number;
    tenantId: number;
    dateRecorded: moment.Moment | undefined;
    bloodPressure: string | undefined;
    heartRate: string | undefined;
    respirationRate: number;
    temperature: number;
    oxygenSaturation: number;
    height: string | undefined;
    weight: string | undefined;
    bmi: string | undefined;
    notes: string | undefined;
    patient: PatientDto;
    nurse: NurseDto;

    constructor(data?: IVitalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.dateRecorded = _data["dateRecorded"] ? moment(_data["dateRecorded"].toString()) : <any>undefined;
            this.bloodPressure = _data["bloodPressure"];
            this.heartRate = _data["heartRate"];
            this.respirationRate = _data["respirationRate"];
            this.temperature = _data["temperature"];
            this.oxygenSaturation = _data["oxygenSaturation"];
            this.height = _data["height"];
            this.weight = _data["weight"];
            this.bmi = _data["bmi"];
            this.notes = _data["notes"];
            this.patient = _data["patient"] ? PatientDto.fromJS(_data["patient"]) : <any>undefined;
            this.nurse = _data["nurse"] ? NurseDto.fromJS(_data["nurse"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VitalDto {
        data = typeof data === 'object' ? data : {};
        let result = new VitalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["dateRecorded"] = this.dateRecorded ? this.dateRecorded.toISOString() : <any>undefined;
        data["bloodPressure"] = this.bloodPressure;
        data["heartRate"] = this.heartRate;
        data["respirationRate"] = this.respirationRate;
        data["temperature"] = this.temperature;
        data["oxygenSaturation"] = this.oxygenSaturation;
        data["height"] = this.height;
        data["weight"] = this.weight;
        data["bmi"] = this.bmi;
        data["notes"] = this.notes;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>undefined;
        data["nurse"] = this.nurse ? this.nurse.toJSON() : <any>undefined;
        return data;
    }

    clone(): VitalDto {
        const json = this.toJSON();
        let result = new VitalDto();
        result.init(json);
        return result;
    }
}

export interface IVitalDto {
    id: number;
    tenantId: number;
    dateRecorded: moment.Moment | undefined;
    bloodPressure: string | undefined;
    heartRate: string | undefined;
    respirationRate: number;
    temperature: number;
    oxygenSaturation: number;
    height: string | undefined;
    weight: string | undefined;
    bmi: string | undefined;
    notes: string | undefined;
    patient: PatientDto;
    nurse: NurseDto;
}

export class VitalDtoPagedResultDto implements IVitalDtoPagedResultDto {
    items: VitalDto[] | undefined;
    totalCount: number;

    constructor(data?: IVitalDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(VitalDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VitalDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new VitalDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): VitalDtoPagedResultDto {
        const json = this.toJSON();
        let result = new VitalDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IVitalDtoPagedResultDto {
    items: VitalDto[] | undefined;
    totalCount: number;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}